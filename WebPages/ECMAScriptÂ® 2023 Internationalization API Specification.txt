https://tc39.es/ecma402/
ECMAScriptÂ® 2023 Internationalization API Specification â˜° Pins Table of Contents Introduction 1 Scope 2 Conformance 3 Normative References â—¢4 Overview 4.1 Internationalization, Localization, and Globalization 4.2 API Overview 4.3 API Conventions â—¢4.4 Implementation Dependencies 4.4.1 Compatibility across implementations â—¢5 Notational Conventions 5.1 Well-Known Intrinsic Objects â—¢6 Identification of Locales, Currencies, Time Zones, and Measurement Units 6.1 Case Sensitivity and Case Mapping â—¢6.2 Language Tags 6.2.1 Unicode Locale Extension Sequences 6.2.2 IsStructurallyValidLanguageTag ( locale ) 6.2.3 CanonicalizeUnicodeLocaleId ( locale ) 6.2.4 DefaultLocale ( ) â—¢6.3 Currency Codes 6.3.1 IsWellFormedCurrencyCode ( currency ) â—¢6.4 Time Zone Names 6.4.1 IsValidTimeZoneName ( timeZone ) 6.4.2 CanonicalizeTimeZoneName ( timeZone ) 6.4.3 DefaultTimeZone ( ) â—¢6.5 Measurement Unit Identifiers 6.5.1 IsWellFormedUnitIdentifier ( unitIdentifier ) 6.5.2 IsSanctionedSingleUnitIdentifier ( unitIdentifier ) 7 Requirements for Standard Built-in ECMAScript Objects â—¢8 The Intl Object â—¢8.1 Value Properties of the Intl Object 8.1.1 Intl[ @@toStringTag ] â—¢8.2 Constructor Properties of the Intl Object 8.2.1 Intl.Collator ( . . . ) 8.2.2 Intl.DateTimeFormat ( . . . ) 8.2.3 Intl.DisplayNames ( . . . ) 8.2.4 Intl.ListFormat ( . . . ) 8.2.5 Intl.Locale ( . . . ) 8.2.6 Intl.NumberFormat ( . . . ) 8.2.7 Intl.PluralRules ( . . . ) 8.2.8 Intl.RelativeTimeFormat ( . . . ) 8.2.9 Intl.Segmenter ( . . . ) â—¢8.3 Function Properties of the Intl Object 8.3.1 Intl.getCanonicalLocales ( locales ) â—¢9 Locale and Parameter Negotiation 9.1 Internal slots of Service Constructors â—¢9.2 Abstract Operations 9.2.1 CanonicalizeLocaleList ( locales ) 9.2.2 BestAvailableLocale ( availableLocales, locale ) 9.2.3 LookupMatcher ( availableLocales, requestedLocales ) 9.2.4 BestFitMatcher ( availableLocales, requestedLocales ) 9.2.5 UnicodeExtensionComponents ( extension ) 9.2.6 InsertUnicodeExtensionAndCanonicalize ( locale, extension ) 9.2.7 ResolveLocale ( availableLocales, requestedLocales, options, relevantExtensionKeys, localeData ) 9.2.8 LookupSupportedLocales ( availableLocales, requestedLocales ) 9.2.9 BestFitSupportedLocales ( availableLocales, requestedLocales ) 9.2.10 SupportedLocales ( availableLocales, requestedLocales, options ) 9.2.11 GetOptionsObject ( options ) 9.2.12 CoerceOptionsToObject ( options ) 9.2.13 GetOption ( options, property, type, values, fallback ) 9.2.14 DefaultNumberOption ( value, minimum, maximum, fallback ) 9.2.15 GetNumberOption ( options, property, minimum, maximum, fallback ) 9.2.16 PartitionPattern ( pattern ) â—¢10 Collator Objects â—¢10.1 The Intl.Collator Constructor 10.1.1 Intl.Collator ( [ locales [ , options ] ] ) 10.1.2 InitializeCollator ( collator, locales, options ) â—¢10.2 Properties of the Intl.Collator Constructor 10.2.1 Intl.Collator.prototype 10.2.2 Intl.Collator.supportedLocalesOf ( locales [ , options ] ) 10.2.3 Internal slots â—¢10.3 Properties of the Intl.Collator Prototype Object 10.3.1 Intl.Collator.prototype.constructor 10.3.2 Intl.Collator.prototype [ @@toStringTag ] â—¢10.3.3 get Intl.Collator.prototype.compare 10.3.3.1 Collator Compare Functions 10.3.3.2 CompareStrings ( collator, x, y ) 10.3.4 Intl.Collator.prototype.resolvedOptions ( ) 10.4 Properties of Intl.Collator Instances â—¢11 DateTimeFormat Objects â—¢11.1 The Intl.DateTimeFormat Constructor â—¢11.1.1 Intl.DateTimeFormat ( [ locales [ , options ] ] ) 11.1.1.1 ChainDateTimeFormat ( dateTimeFormat, newTarget, this ) 11.1.2 InitializeDateTimeFormat ( dateTimeFormat, locales, options ) â—¢11.2 Properties of the Intl.DateTimeFormat Constructor 11.2.1 Intl.DateTimeFormat.prototype 11.2.2 Intl.DateTimeFormat.supportedLocalesOf ( locales [ , options ] ) 11.2.3 Internal slots â—¢11.3 Properties of the Intl.DateTimeFormat Prototype Object 11.3.1 Intl.DateTimeFormat.prototype.constructor 11.3.2 Intl.DateTimeFormat.prototype [ @@toStringTag ] 11.3.3 get Intl.DateTimeFormat.prototype.format 11.3.4 Intl.DateTimeFormat.prototype.formatToParts ( date ) 11.3.5 Intl.DateTimeFormat.prototype.formatRange ( startDate, endDate ) 11.3.6 Intl.DateTimeFormat.prototype.formatRangeToParts ( startDate, endDate ) 11.3.7 Intl.DateTimeFormat.prototype.resolvedOptions ( ) 11.4 Properties of Intl.DateTimeFormat Instances â—¢11.5 Abstract Operations for DateTimeFormat Objects 11.5.1 ToDateTimeOptions ( options, required, defaults ) 11.5.2 DateTimeStyleFormat ( dateStyle, timeStyle, styles ) 11.5.3 BasicFormatMatcher ( options, formats ) 11.5.4 BestFitFormatMatcher ( options, formats ) 11.5.5 DateTime Format Functions 11.5.6 FormatDateTimePattern ( dateTimeFormat, patternParts, x, rangeFormatOptions ) 11.5.7 PartitionDateTimePattern ( dateTimeFormat, x ) 11.5.8 FormatDateTime ( dateTimeFormat, x ) 11.5.9 FormatDateTimeToParts ( dateTimeFormat, x ) 11.5.10 PartitionDateTimeRangePattern ( dateTimeFormat, x, y ) 11.5.11 FormatDateTimeRange ( dateTimeFormat, x, y ) 11.5.12 FormatDateTimeRangeToParts ( dateTimeFormat, x, y ) 11.5.13 ToLocalTime ( t, calendar, timeZone ) 11.5.14 UnwrapDateTimeFormat ( dtf ) â—¢12 DisplayNames Objects â—¢12.1 The Intl.DisplayNames Constructor 12.1.1 Intl.DisplayNames ( locales, options ) â—¢12.2 Properties of the Intl.DisplayNames Constructor 12.2.1 Intl.DisplayNames.prototype 12.2.2 Intl.DisplayNames.supportedLocalesOf ( locales [ , options ] ) 12.2.3 Internal slots â—¢12.3 Properties of the Intl.DisplayNames Prototype Object 12.3.1 Intl.DisplayNames.prototype.constructor 12.3.2 Intl.DisplayNames.prototype[ @@toStringTag ] 12.3.3 Intl.DisplayNames.prototype.of ( code ) 12.3.4 Intl.DisplayNames.prototype.resolvedOptions ( ) 12.4 Properties of Intl.DisplayNames Instances â—¢12.5 Abstract Operations for DisplayNames Objects 12.5.1 CanonicalCodeForDisplayNames ( type, code ) 12.5.2 IsValidDateTimeFieldCode ( field ) â—¢13 ListFormat Objects â—¢13.1 The Intl.ListFormat Constructor 13.1.1 Intl.ListFormat ( [ locales [ , options ] ] ) â—¢13.2 Properties of the Intl.ListFormat Constructor 13.2.1 Intl.ListFormat.prototype 13.2.2 Intl.ListFormat.supportedLocalesOf ( locales [ , options ] ) 13.2.3 Internal slots â—¢13.3 Properties of the Intl.ListFormat Prototype Object 13.3.1 Intl.ListFormat.prototype.constructor 13.3.2 Intl.ListFormat.prototype [ @@toStringTag ] 13.3.3 Intl.ListFormat.prototype.format ( list ) 13.3.4 Intl.ListFormat.prototype.formatToParts ( list ) 13.3.5 Intl.ListFormat.prototype.resolvedOptions ( ) 13.4 Properties of Intl.ListFormat Instances â—¢13.5 Abstract Operations for ListFormat Objects 13.5.1 DeconstructPattern ( pattern, placeables ) 13.5.2 CreatePartsFromList ( listFormat, list ) 13.5.3 FormatList ( listFormat, list ) 13.5.4 FormatListToParts ( listFormat, list ) 13.5.5 StringListFromIterable ( iterable ) â—¢14 Locale Objects â—¢14.1 The Intl.Locale Constructor 14.1.1 Intl.Locale ( tag [ , options ] ) 14.1.2 ApplyOptionsToTag ( tag, options ) 14.1.3 ApplyUnicodeExtensionToTag ( tag, options, relevantExtensionKeys ) â—¢14.2 Properties of the Intl.Locale Constructor 14.2.1 Intl.Locale.prototype 14.2.2 Internal slots â—¢14.3 Properties of the Intl.Locale Prototype Object 14.3.1 Intl.Locale.prototype.constructor 14.3.2 Intl.Locale.prototype[ @@toStringTag ] 14.3.3 Intl.Locale.prototype.maximize ( ) 14.3.4 Intl.Locale.prototype.minimize ( ) 14.3.5 Intl.Locale.prototype.toString ( ) 14.3.6 get Intl.Locale.prototype.baseName 14.3.7 get Intl.Locale.prototype.calendar 14.3.8 get Intl.Locale.prototype.caseFirst 14.3.9 get Intl.Locale.prototype.collation 14.3.10 get Intl.Locale.prototype.hourCycle 14.3.11 get Intl.Locale.prototype.numeric 14.3.12 get Intl.Locale.prototype.numberingSystem 14.3.13 get Intl.Locale.prototype.language 14.3.14 get Intl.Locale.prototype.script 14.3.15 get Intl.Locale.prototype.region â—¢15 NumberFormat Objects â—¢15.1 The Intl.NumberFormat Constructor â—¢15.1.1 Intl.NumberFormat ( [ locales [ , options ] ] ) 15.1.1.1 ChainNumberFormat ( numberFormat, newTarget, this ) 15.1.2 InitializeNumberFormat ( numberFormat, locales, options ) 15.1.3 SetNumberFormatDigitOptions ( intlObj, options, mnfdDefault, mxfdDefault, notation ) 15.1.4 SetNumberFormatUnitOptions ( intlObj, options ) â—¢15.2 Properties of the Intl.NumberFormat Constructor 15.2.1 Intl.NumberFormat.prototype 15.2.2 Intl.NumberFormat.supportedLocalesOf ( locales [ , options ] ) 15.2.3 Internal slots â—¢15.3 Properties of the Intl.NumberFormat Prototype Object 15.3.1 Intl.NumberFormat.prototype.constructor 15.3.2 Intl.NumberFormat.prototype [ @@toStringTag ] 15.3.3 get Intl.NumberFormat.prototype.format 15.3.4 Intl.NumberFormat.prototype.formatToParts ( value ) 15.3.5 Intl.NumberFormat.prototype.resolvedOptions ( ) 15.4 Properties of Intl.NumberFormat Instances â—¢15.5 Abstract Operations for NumberFormat Objects 15.5.1 CurrencyDigits ( currency ) 15.5.2 Number Format Functions 15.5.3 FormatNumericToString ( intlObject, x ) 15.5.4 PartitionNumberPattern ( numberFormat, x ) 15.5.5 PartitionNotationSubPattern ( numberFormat, x, n, exponent ) 15.5.6 FormatNumeric ( numberFormat, x ) 15.5.7 FormatNumericToParts ( numberFormat, x ) 15.5.8 ToRawPrecision ( x, minPrecision, maxPrecision ) 15.5.9 ToRawFixed ( x, minInteger, minFraction, maxFraction ) 15.5.10 UnwrapNumberFormat ( nf ) 15.5.11 GetNumberFormatPattern ( numberFormat, x ) 15.5.12 GetNotationSubPattern ( numberFormat, exponent ) 15.5.13 ComputeExponent ( numberFormat, x ) 15.5.14 ComputeExponentForMagnitude ( numberFormat, magnitude ) â—¢16 PluralRules Objects â—¢16.1 The Intl.PluralRules Constructor 16.1.1 Intl.PluralRules ( [ locales [ , options ] ] ) 16.1.2 InitializePluralRules ( pluralRules, locales, options ) â—¢16.2 Properties of the Intl.PluralRules Constructor 16.2.1 Intl.PluralRules.prototype 16.2.2 Intl.PluralRules.supportedLocalesOf ( locales [ , options ] ) 16.2.3 Internal slots â—¢16.3 Properties of the Intl.PluralRules Prototype Object 16.3.1 Intl.PluralRules.prototype.constructor 16.3.2 Intl.PluralRules.prototype [ @@toStringTag ] 16.3.3 Intl.PluralRules.prototype.select ( value ) 16.3.4 Intl.PluralRules.prototype.resolvedOptions ( ) 16.4 Properties of Intl.PluralRules Instances â—¢16.5 Abstract Operations for PluralRules Objects 16.5.1 GetOperands ( s ) 16.5.2 PluralRuleSelect ( locale, type, n, operands ) 16.5.3 ResolvePlural ( pluralRules, n ) â—¢17 RelativeTimeFormat Objects â—¢17.1 The Intl.RelativeTimeFormat Constructor 17.1.1 Intl.RelativeTimeFormat ( [ locales [ , options ] ] ) 17.1.2 InitializeRelativeTimeFormat ( relativeTimeFormat, locales, options ) â—¢17.2 Properties of the Intl.RelativeTimeFormat Constructor 17.2.1 Intl.RelativeTimeFormat.prototype 17.2.2 Intl.RelativeTimeFormat.supportedLocalesOf ( locales [ , options ] ) 17.2.3 Internal slots â—¢17.3 Properties of the Intl.RelativeTimeFormat Prototype Object 17.3.1 Intl.RelativeTimeFormat.prototype.constructor 17.3.2 Intl.RelativeTimeFormat.prototype[ @@toStringTag ] 17.3.3 Intl.RelativeTimeFormat.prototype.format ( value, unit ) 17.3.4 Intl.RelativeTimeFormat.prototype.formatToParts ( value, unit ) 17.3.5 Intl.RelativeTimeFormat.prototype.resolvedOptions ( ) 17.4 Properties of Intl.RelativeTimeFormat Instances â—¢17.5 Abstract Operations for RelativeTimeFormat Objects 17.5.1 SingularRelativeTimeUnit ( unit ) 17.5.2 PartitionRelativeTimePattern ( relativeTimeFormat, value, unit ) 17.5.3 MakePartsList ( pattern, unit, parts ) 17.5.4 FormatRelativeTime ( relativeTimeFormat, value, unit ) 17.5.5 FormatRelativeTimeToParts ( relativeTimeFormat, value, unit ) â—¢18 Segmenter Objects â—¢18.1 The Intl.Segmenter Constructor 18.1.1 Intl.Segmenter ( [ locales [ , options ] ] ) â—¢18.2 Properties of the Intl.Segmenter Constructor 18.2.1 Intl.Segmenter.prototype 18.2.2 Intl.Segmenter.supportedLocalesOf ( locales [ , options ] ) 18.2.3 Internal slots â—¢18.3 Properties of the Intl.Segmenter Prototype Object 18.3.1 Intl.Segmenter.prototype.constructor 18.3.2 Intl.Segmenter.prototype [ @@toStringTag ] 18.3.3 Intl.Segmenter.prototype.segment ( string ) 18.3.4 Intl.Segmenter.prototype.resolvedOptions ( ) 18.4 Properties of Intl.Segmenter Instances â—¢18.5 Segments Objects 18.5.1 CreateSegmentsObject ( segmenter, string ) â—¢18.5.2 The %SegmentsPrototype% Object 18.5.2.1 %SegmentsPrototype%.containing ( index ) 18.5.2.2 %SegmentsPrototype% [ @@iterator ] ( ) 18.5.3 Properties of Segments Instances â—¢18.6 Segment Iterator Objects 18.6.1 CreateSegmentIterator ( segmenter, string ) â—¢18.6.2 The %SegmentIteratorPrototype% Object 18.6.2.1 %SegmentIteratorPrototype%.next ( ) 18.6.2.2 %SegmentIteratorPrototype% [ @@toStringTag ] 18.6.3 Properties of Segment Iterator Instances â—¢18.7 Segment Data Objects 18.7.1 CreateSegmentDataObject ( segmenter, string, startIndex, endIndex ) â—¢18.8 Abstract Operations for Segmenter Objects 18.8.1 FindBoundary ( segmenter, string, startIndex, direction ) â—¢19 Locale Sensitive Functions of the ECMAScript Language Specification â—¢19.1 Properties of the String Prototype Object 19.1.1 String.prototype.localeCompare ( that [ , locales [ , options ] ] ) â—¢19.1.2 String.prototype.toLocaleLowerCase ( [ locales ] ) 19.1.2.1 TransformCase ( S, locales, targetCase ) 19.1.3 String.prototype.toLocaleUpperCase ( [ locales ] ) â—¢19.2 Properties of the Number Prototype Object 19.2.1 Number.prototype.toLocaleString ( [ locales [ , options ] ] ) â—¢19.3 Properties of the BigInt Prototype Object 19.3.1 BigInt.prototype.toLocaleString ( [ locales [ , options ] ] ) â—¢19.4 Properties of the Date Prototype Object 19.4.1 Date.prototype.toLocaleString ( [ locales [ , options ] ] ) 19.4.2 Date.prototype.toLocaleDateString ( [ locales [ , options ] ] ) 19.4.3 Date.prototype.toLocaleTimeString ( [ locales [ , options ] ] ) â—¢19.5 Properties of the Array Prototype Object 19.5.1 Array.prototype.toLocaleString ( [ locales [ , options ] ] ) A Implementation Dependent Behaviour B Additions and Changes That Introduce Incompatibilities with Prior Editions C Colophon D Copyright & Software License Draft ECMA-402 / March 28, 2022 ECMAScriptÂ® 2023 Internationalization API Specification Contributing to this Specification This specification is developed on GitHub with the help of the ECMAScript community. There are a number of ways to contribute to the development of this specification: GitHub Repository: https://github.com/tc39/ecma402 Issues: All Issues, File a New Issue Pull Requests: All Pull Requests, Create a New Pull Request Test Suite: Test262 TC39-TG2: Convener: Shane F. Carr (@sffc) Admin group: contact by email Editors: Leo Balter (@leobalter) Richard Gibson (@gibson042) Ujjwal Sharma (@ryzokuken) Community: Matrix: #tc39:matrix.org Matrix: #tc39-ecma402:matrix.org Refer to the colophon for more information on how this document is created. Introduction This specification's source can be found at https://github.com/tc39/ecma402. The ECMAScript 2023 Internationalization API Specification (ECMA-402 10th Edition), provides key language sensitive functionality as a complement to the ECMAScript 2023 Language Specification (ECMA-262 14th Edition or successor). Its functionality has been selected from that of well-established internationalization APIs such as those of the Internationalization Components for Unicode (ICU) library (https://unicode-org.github.io/icu-docs/), of the .NET framework, or of the Java platform. The 1st Edition API was developed by an ad-hoc group established by Ecma TC39 in September 2010 based on a proposal by NebojÅ¡a Ä†iriÄ‡ and Jungshik Shin. The 2nd Edition API was adopted by the General Assembly of June 2015, as a complement to the ECMAScript 6th Edition. The 3rd Edition API was the first edition released under Ecma TC39's new yearly release cadence and open development process. A plain-text source document was built from the ECMA-402 source document to serve as the base for further development entirely on GitHub. Over the year of this standard's development, dozens of pull requests and issues were filed representing several of bug fixes, editorial fixes and other improvements. Additionally, numerous software tools were developed to aid in this effort including Ecmarkup, Ecmarkdown, and Grammarkdown. Dozens of individuals representing many organizations have made very significant contributions within Ecma TC39 to the development of this edition and to the prior editions. In addition, a vibrant community has emerged supporting TC39's ECMAScript efforts. This community has reviewed numerous drafts, filed dozens of bug reports, performed implementation experiments, contributed test suites, and educated the world-wide developer community about ECMAScript Internationalization. Unfortunately, it is impossible to identify and acknowledge every person and organization who has contributed to this effort. Norbert Lindenberg ECMA-402, 1st Edition Project Editor Rick Waldron ECMA-402, 2nd Edition Project Editor Caridy PatiÃ±o ECMA-402, 3rd, 4th and 5th Editions Project Editor Caridy PatiÃ±o, Daniel Ehrenberg, Leo Balter ECMA-402, 6th Edition Project Editors Leo Balter, Valerie Young, Isaac Durazo ECMA-402, 7th Edition Project Editors Leo Balter, Richard Gibson ECMA-402, 8th Edition Project Editors Leo Balter, Richard Gibson, Ujjwal Sharma ECMA-402, 9th Edition Project Editors Richard Gibson, Ujjwal Sharma ECMA-402, 10th Edition Project Editors 1 Scope This Standard defines the application programming interface for ECMAScript objects that support programs that need to adapt to the linguistic and cultural conventions used by different human languages and countries. 2 Conformance A conforming implementation of the ECMAScript 2023 Internationalization API Specification must conform to the ECMAScript 2023 Language Specification (ECMA-262 14th Edition, or successor), and must provide and support all the objects, properties, functions, and program semantics described in this specification. A conforming implementation of the ECMAScript 2023 Internationalization API Specification is permitted to provide additional objects, properties, and functions beyond those described in this specification. In particular, a conforming implementation of the ECMAScript 2023 Internationalization API Specification is permitted to provide properties not described in this specification, and values for those properties, for objects that are described in this specification. A conforming implementation is not permitted to add optional arguments to the functions defined in this specification. A conforming implementation is permitted to accept additional values, and then have implementation-defined behaviour instead of throwing a RangeError, for the following properties of options arguments: The options property "localeMatcher" in all constructors and supportedLocalesOf methods. The options properties "usage" and "sensitivity" in the Collator constructor. The options properties "style", "currencyDisplay", "notation", "compactDisplay", "signDisplay", "currencySign", and "unitDisplay" in the NumberFormat constructor. The options properties "minimumIntegerDigits", "minimumFractionDigits", "maximumFractionDigits", "minimumSignificantDigits", and "maximumSignificantDigits" in the NumberFormat constructor, provided that the additional values are interpreted as integer values higher than the specified limits. The options properties listed in Table 6 in the DateTimeFormat constructor. The options property "formatMatcher" in the DateTimeFormat constructor. The options properties "minimumIntegerDigits", "minimumFractionDigits", "maximumFractionDigits", and "minimumSignificantDigits" in the PluralRules constructor, provided that the additional values are interpreted as integer values higher than the specified limits. The options property "type" in the PluralRules constructor. The options property "style" and "numeric" in the RelativeTimeFormat constructor. The options property "style" and "type" in the DisplayNames constructor. 3 Normative References The following referenced documents are required for the application of this document. For dated references, only the edition cited applies. For undated references, the latest edition of the referenced document (including any amendments) applies. ECMAScript 2023 Language Specification (ECMA-262 14th Edition, or successor). https://www.ecma-international.org/publications/standards/Ecma-262.htm Note Throughout this document, the phrase â€œes2023, xâ€? (where x is a sequence of numbers separated by periods) may be used as shorthand for "ECMAScript 2023 Language Specification (ECMA-262 14th Edition, sub clause x)". ISO/IEC 10646:2014: Information Technology â€“ Universal Multiple-Octet Coded Character Set (UCS) plus Amendment 1:2015 and Amendment 2, plus additional amendments and corrigenda, or successor https://www.iso.org/iso/catalogue_detail.htm?csnumber=63182 https://www.iso.org/iso/catalogue_detail.htm?csnumber=65047 https://www.iso.org/iso/catalogue_detail.htm?csnumber=66791 ISO 4217:2015, Codes for the representation of currencies and funds, or successor IETF RFC 4647, Matching of Language Tags, or successor IANA Time Zone Database The Unicode Standard Unicode Standard Annex #29: Unicode Text Segmentation Unicode Technical Standard 35 Unicode Locale Data Markup Language Unicode BCP 47 Locale Identifiers 4 Overview This section contains a non-normative overview of the ECMAScript 2023 Internationalization API Specification. 4.1 Internationalization, Localization, and Globalization Internationalization of software means designing it such that it supports or can be easily adapted to support the needs of users speaking different languages and having different cultural expectations, and enables worldwide communication between them. Localization then is the actual adaptation to a specific language and culture. Globalization of software is commonly understood to be the combination of internationalization and localization. Globalization starts at the lowest level by using a text representation that supports all languages in the world, and using standard identifiers to identify languages, countries, time zones, and other relevant parameters. It continues with using a user interface language and data presentation that the user understands, and finally often requires product-specific adaptations to the user's language, culture, and environment. The ECMAScript 2023 Language Specification lays the foundation by using Unicode for text representation and by providing a few language-sensitive functions, but gives applications little control over the behaviour of these functions. The ECMAScript 2023 Internationalization API Specification builds on this by providing a set of customizable language-sensitive functionality. The API is useful even for applications that themselves are not internationalized, as even applications targeting only one language and one region need to properly support that one language and region. However, the API also enables applications that support multiple languages and regions, even concurrently, as may be needed in server environments. 4.2 API Overview The ECMAScript 2023 Internationalization API Specification is designed to complement the ECMAScript 2023 Language Specification by providing key language-sensitive functionality. The API can be added to an implementation of the ECMAScript 2023 Language Specification (ECMA-262 14th Edition, or successor). The ECMAScript 2023 Internationalization API Specification provides several key pieces of language-sensitive functionality that are required in most applications: String comparison (collation), number formatting, date and time formatting, relative time formatting, display names, list formatting, locale selection and operation, pluralization rules, case conversion, and text segmentation. While the ECMAScript 2023 Language Specification provides functions for this basic functionality (on Array.prototype: toLocaleString; on String.prototype: localeCompare, toLocaleLowerCase, toLocaleUpperCase; on Number.prototype: toLocaleString; on Date.prototype: toLocaleString, toLocaleDateString, and toLocaleTimeString), their actual behaviour is left largely implemenation-defined. The ECMAScript 2023 Internationalization API Specification provides additional functionality, control over the language and over details of the behaviour to be used, and a more complete specification of required functionality. Applications can use the API in two ways: Directly, by using a service constructor to construct an object, specifying a list of preferred languages and options to configure its behaviour. The object provides a main function (compare, select, format, etc.), which can be called repeatedly. It also provides a resolvedOptions function, which the application can use to find out the exact configuration of the object. Indirectly, by using the functions of the ECMAScript 2023 Language Specification mentioned above. The collation and formatting functions are respecified in this specification to accept the same arguments as the Collator, NumberFormat, and DateTimeFormat constructors and produce the same results as their compare or format methods. The case conversion functions are respecified to accept a list of preferred languages. The Intl object is used to package all functionality defined in the ECMAScript 2023 Internationalization API Specification to avoid name collisions. Note While the API includes a variety of formatters, it does not provide any parsing facilities. This is intentional, has been discussed extensively, and concluded after weighing in all the benefits and drawbacks of including said functionality. See the discussion on the issue tracker. 4.3 API Conventions Every Intl constructor should behave as if defined by a class, throwing a TypeError exception when called as a function (without NewTarget). For backwards compatibility with past editions, this does not apply to %Collator%, %DateTimeFormat%, or %NumberFormat%, each of which construct and return a new object when called as a function. Note In ECMA 402 v1, Intl constructors supported a mode of operation where calling them with an existing object as a receiver would add relevant internal slots to the receiver, effectively transforming it into an instance of the class. In ECMA 402 v2, this capability was removed, to avoid adding internal slots to existing objects. In ECMA 402 v3, the capability was re-added as "normative optional" in a mode which chains the underlying Intl instance on any object, when the constructor is called. See Issue 57 for details. 4.4 Implementation Dependencies Due to the nature of internationalization, the API specification has to leave several details implementation dependent: The set of locales that an implementation supports with adequate localizations: Linguists estimate the number of human languages to around 6000, and the more widely spoken ones have variations based on regions or other parameters. Even large locale data collections, such as the Common Locale Data Repository, cover only a subset of this large set. Implementations targeting resource-constrained devices may have to further reduce the subset. The exact form of localizations such as format patterns: In many cases locale-dependent conventions are not standardized, so different forms may exist side by side, or they vary over time. Different internationalization libraries may have implemented different forms, without any of them being actually wrong. In order to allow this API to be implemented on top of existing libraries, such variations have to be permitted. Subsets of Unicode: Some operations, such as collation, operate on strings that can include characters from the entire Unicode character set. However, both the Unicode Standard and the ECMAScript standard allow implementations to limit their functionality to subsets of the Unicode character set. In addition, locale conventions typically don't specify the desired behaviour for the entire Unicode character set, but only for those characters that are relevant for the locale. While the Unicode Collation Algorithm combines a default collation order for the entire Unicode character set with the ability to tailor for local conventions, subsets and tailorings still result in differences in behaviour. 4.4.1 Compatibility across implementations ECMA 402 describes the schema of the data used by its functions. The data contained inside is implementation-dependent, and expected to change over time and vary between implementations. The variation is visible by programmers, and it is possible to construct programs which will depend on a particular output. However, this specification attempts to describe reasonable constraints which will allow well-written programs to function across implementations. Implementations are encouraged to continue their efforts to harmonize linguistic data. 5 Notational Conventions This standard uses a subset of the notational conventions of the ECMAScript 2023 Language Specification (ECMA-262 14th Edition), as es2023: Object Internal Methods and Internal Slots, as described in es2023, 6.1.7.2. Algorithm conventions, as described in es2023, 5.2, and the use of abstract operations, as described in es2023, 7.1, 7.2, 7.3, 7.4. Internal Slots, as described in es2023, 9.1. The List and Record Specification Type, as described in es2023, 6.2.1. Note As described in the ECMAScript Language Specification, algorithms are used to precisely specify the required semantics of ECMAScript constructs, but are not intended to imply the use of any specific implementation technique. Internal slots are used to define the semantics of object values, but are not part of the API. They are defined purely for expository purposes. An implementation of the API must behave as if it produced and operated upon internal slots in the manner described here. As an extension to the Record Specification Type, the notation â€œ[[<name>]]â€? denotes a field whose name is given by the variable name, which must have a String value. For example, if a variable s has the value "a", then [[<s>]] denotes the field [[a]]. This specification uses blocks demarcated as Normative Optional to denote the sense of Annex B in ECMA 262. That is, normative optional sections are required when the ECMAScript host is a web browser. The content of the section is normative but optional if the ECMAScript host is not a web browser. 5.1 Well-Known Intrinsic Objects The following table extends the Well-Known Intrinsic Objects table defined in es2023, 6.1.7.4. Table 1: Well-known Intrinsic Objects (Extensions) Intrinsic Name Global Name ECMAScript Language Association %Collator% Intl.Collator The Intl.Collator constructor (10.1) %DateTimeFormat% Intl.DateTimeFormat The Intl.DateTimeFormat constructor (11.1). %DisplayNames% Intl.DisplayNames The Intl.DisplayNames constructor (12.1). %Intl% Intl The Intl object (8). %ListFormat% Intl.ListFormat The Intl.ListFormat constructor (13.1). %Locale% Intl.Locale The Intl.Locale constructor (14.1). %NumberFormat% Intl.NumberFormat The Intl.NumberFormat constructor (15.1) %PluralRules% Intl.PluralRules The Intl.PluralRules constructor (16.1). %RelativeTimeFormat% Intl.RelativeTimeFormat The Intl.RelativeTimeFormat constructor (17.1). %Segmenter% Intl.Segmenter The Intl.Segmenter constructor (18.1). 6 Identification of Locales, Currencies, Time Zones, and Measurement Units This clause describes the String values used in the ECMAScript 2023 Internationalization API Specification to identify locales, currencies, time zones, and measurement units. 6.1 Case Sensitivity and Case Mapping The String values used to identify locales, currencies, scripts, and time zones are interpreted in an ASCII-case-insensitive manner, treating the code units 0x0041 through 0x005A (corresponding to Unicode characters LATIN CAPITAL LETTER A through LATIN CAPITAL LETTER Z) as equivalent to the corresponding code units 0x0061 through 0x007A (corresponding to Unicode characters LATIN SMALL LETTER A through LATIN SMALL LETTER Z), both inclusive. No other case folding equivalences are applied. Note For example, "ÃŸ" (U+00DF) must not match or be mapped to "SS" (U+0053, U+0053). "Ä±" (U+0131) must not match or be mapped to "I" (U+0049). The ASCII-uppercase of a String value S is the String value derived from S by replacing each occurrence of an ASCII lowercase letter code unit (0x0061 through 0x007A, inclusive) with the corresponding ASCII uppercase letter code unit (0x0041 through 0x005A, inclusive) while preserving all other code units. The ASCII-lowercase of a String value S is the String value derived from S by replacing each occurrence of an ASCII uppercase letter code unit (0x0041 through 0x005A, inclusive) with the corresponding ASCII lowercase letter code unit (0x0061 through 0x007A, inclusive) while preserving all other code units. A String value A is an ASCII-case-insensitive match for String value B if the ASCII-uppercase of A is exactly the same sequence of code units as the ASCII-uppercase of B. A sequence of Unicode code points A is an ASCII-case-insensitive match for B if B is an ASCII-case-insensitive match for ! CodePointsToString(A). 6.2 Language Tags The ECMAScript 2023 Internationalization API Specification identifies locales using Unicode BCP 47 locale identifiers as defined by Unicode Technical Standard #35 LDML Â§ 3 Unicode Language and Locale Identifiers, which may include extensions such as the Unicode BCP 47 U Extension. Their canonical form is specified in Unicode Technical Standard #35 LDML Â§ 3.2.1 Canonical Unicode Locale Identifiers. Unicode BCP 47 locale identifiers are structurally valid when they match those syntactical formatting criteria of Unicode Technical Standard 35, section 3.2, but it is not required to validate them according to the Unicode validation data. All structurally valid language tags are valid for use with the APIs defined by this standard. However, the set of locales and thus language tags that an implementation supports with adequate localizations is implementation dependent. Intl constructors map the language tags used in requests to locales supported by their respective implementations. 6.2.1 Unicode Locale Extension Sequences This standard uses the term "Unicode locale extension sequence" - as described in unicode_locale_extensions in UTS 35 Unicode Locale Identifier, section 3.2 - for any substring of a language tag that is not part of a private use subtag sequence, starts with a separator "-" and the singleton "u", and includes the maximum sequence of following non-singleton subtags and their preceding "-" separators. 6.2.2 IsStructurallyValidLanguageTag ( locale ) The IsStructurallyValidLanguageTag abstract operation determines whether the locale argument (which must be a String value) is a language tag recognized by this specification. (It does not consider whether the language tag conveys any meaningful semantics, differentiate between aliased subtags and their preferred replacement subtags, or require canonical casing or subtag ordering.) IsStructurallyValidLanguageTag returns true if all of the following conditions hold, false otherwise: locale can be generated from the EBNF grammar for unicode_locale_id in Unicode Technical Standard #35 LDML Â§ 3.2 Unicode Locale Identifier; locale does not use any of the backwards compatibility syntax described in Unicode Technical Standard #35 LDML Â§ 3.3 BCP 47 Conformance; the unicode_language_id within locale contains no duplicate unicode_variant_subtag subtags; and if locale contains an extensions* component, that component does not contain any other_extensions components with duplicate [alphanum-[tTuUxX]] subtags, contains at most one unicode_locale_extensions component, contains at most one transformed_extensions component, and if a transformed_extensions component that contains a tlang component is present, then the tlang component contains no duplicate unicode_variant_subtag subtags. When evaluating each condition, terminal value characters in the grammar are interpreted as the corresponding Basic Latin code points. Two subtags are duplicates if one is an ASCII-case-insensitive match for the other. Note Every string for which this function returns true is both a "Unicode BCP 47 locale identifier", consistent with Unicode Technical Standard #35 LDML Â§ 3.2 Unicode Locale Identifier and Unicode Technical Standard #35 LDML Â§ 3.3 BCP 47 Conformance, and a valid BCP 47 language tag. 6.2.3 CanonicalizeUnicodeLocaleId ( locale ) The CanonicalizeUnicodeLocaleId abstract operation returns the canonical and case-regularized form of the locale argument (which must be a String value for which IsStructurallyValidLanguageTag(locale) equals true). The following steps are taken: Let localeId be the string locale after performing the algorithm to transform it to canonical syntax per Unicode Technical Standard #35 LDML Â§ 3.2.1 Canonical Unicode Locale Identifiers. (The result is a Unicode BCP 47 locale identifier, in canonical syntax but not necessarily in canonical form.) Let localeId be the string localeId after performing the algorithm to transform it to canonical form. (The result is a Unicode BCP 47 locale identifier, in both canonical syntax and canonical form.) If localeId contains a substring extension that is a Unicode locale extension sequence, then Let components be ! UnicodeExtensionComponents(extension). Let attributes be components.[[Attributes]]. Let keywords be components.[[Keywords]]. Let newExtension be "u". For each element attr of attributes, do Append "-" to newExtension. Append attr to newExtension. For each Record { [[Key]], [[Value]] } keyword in keywords, do Append "-" to newExtension. Append keyword.[[Key]] to newExtension. If keyword.[[Value]] is not the empty String, then Append "-" to newExtension. Append keyword.[[Value]] to newExtension. Assert: newExtension is not equal to "u". Let localeId be localeId with the substring corresponding to extension replaced by the string newExtension. Return localeId. Note The third step of this algorithm ensures that a Unicode locale extension sequence in the returned language tag contains: only the first instance of any attribute duplicated in the input, and only the first keyword for a given key in the input. 6.2.4 DefaultLocale ( ) The DefaultLocale abstract operation returns a String value representing the structurally valid (6.2.2) and canonicalized (6.2.3) Unicode BCP 47 locale identifier for the host environment's current locale. 6.3 Currency Codes The ECMAScript 2023 Internationalization API Specification identifies currencies using 3-letter currency codes as defined by ISO 4217. Their canonical form is uppercase. All well-formed 3-letter ISO 4217 currency codes are allowed. However, the set of combinations of currency code and language tag for which localized currency symbols are available is implementation dependent. Where a localized currency symbol is not available, the ISO 4217 currency code is used for formatting. 6.3.1 IsWellFormedCurrencyCode ( currency ) The IsWellFormedCurrencyCode abstract operation verifies that the currency argument (which must be a String value) represents a well-formed 3-letter ISO currency code. The following steps are taken: If the length of currency is not 3, return false. Let normalized be the ASCII-uppercase of currency. If normalized contains any code unit outside of 0x0041 through 0x005A (corresponding to Unicode characters LATIN CAPITAL LETTER A through LATIN CAPITAL LETTER Z), return false. Return true. 6.4 Time Zone Names The ECMAScript 2023 Internationalization API Specification identifies time zones using the Zone and Link names of the IANA Time Zone Database. Their canonical form is the corresponding Zone name in the casing used in the IANA Time Zone Database except as specifically overridden by CanonicalizeTimeZoneName. A conforming implementation must recognize "UTC" and all other Zone and Link names (and only such names), and use best available current and historical information about their offsets from UTC and their daylight saving time rules in calculations. However, the set of combinations of time zone name and language tag for which localized time zone names are available is implementation dependent. 6.4.1 IsValidTimeZoneName ( timeZone ) The abstract operation IsValidTimeZoneName takes argument timeZone, a String value, and verifies that it represents a valid Zone or Link name of the IANA Time Zone Database. If one of the Zone or Link names of the IANA Time Zone Database is an ASCII-case-insensitive match of timeZone, return true. If timeZone is an ASCII-case-insensitive match of "UTC", return true. Return false. Note Any value returned from DefaultTimeZone must be recognized as valid. 6.4.2 CanonicalizeTimeZoneName ( timeZone ) The abstract operation CanonicalizeTimeZoneName takes argument timeZone (a String value that is a valid time zone name as verified by IsValidTimeZoneName). It returns the canonical and case-regularized form of timeZone. It performs the following steps when called: Let ianaTimeZone be the String value of the Zone or Link name of the IANA Time Zone Database that is an ASCII-case-insensitive match of timeZone. If ianaTimeZone is a Link name, let ianaTimeZone be the String value of the corresponding Zone name as specified in the file backward of the IANA Time Zone Database. If ianaTimeZone is "Etc/UTC" or "Etc/GMT", return "UTC". Return ianaTimeZone. 6.4.3 DefaultTimeZone ( ) The DefaultTimeZone abstract operation returns a String value representing the valid (6.4.1) and canonicalized (6.4.2) time zone name for the host environment's current time zone. 6.5 Measurement Unit Identifiers The ECMAScript 2023 Internationalization API Specification identifies measurement units using a core unit identifier (or equivalently core unit ID) as defined by Unicode Technical Standard #35, Part 2, Section 6.2. Their canonical form is a string containing only Unicode Basic Latin lowercase letters (U+0061 LATIN SMALL LETTER A through U+007A LATIN SMALL LETTER Z) with zero or more medial hyphens (U+002D HYPHEN-MINUS). Only a limited set of core unit identifiers are sanctioned. Attempting to use an unsanctioned core unit identifier results in a RangeError. 6.5.1 IsWellFormedUnitIdentifier ( unitIdentifier ) The IsWellFormedUnitIdentifier abstract operation verifies that the unitIdentifier argument (which must be a String value) represents a well-formed UTS #35 core unit identifier that is either a sanctioned single unit or a complex unit formed by division of two sanctioned single units. The following steps are taken: If ! IsSanctionedSingleUnitIdentifier(unitIdentifier) is true, then Return true. Let i be ! StringIndexOf(unitIdentifier, "-per-", 0). If i is -1 or ! StringIndexOf(unitIdentifier, "-per-", i + 1) is not -1, then Return false. Assert: The five-character substring "-per-" occurs exactly once in unitIdentifier, at index i. Let numerator be the substring of unitIdentifier from 0 to i. Let denominator be the substring of unitIdentifier from i + 5. If ! IsSanctionedSingleUnitIdentifier(numerator) and ! IsSanctionedSingleUnitIdentifier(denominator) are both true, then Return true. Return false. 6.5.2 IsSanctionedSingleUnitIdentifier ( unitIdentifier ) The IsSanctionedSingleUnitIdentifier abstract operation verifies that the unitIdentifier argument (which must be a String value) is among the single unit identifiers sanctioned in the current version of the ECMAScript Internationalization API Specification, which are a subset of the Common Locale Data Repository release 38 unit validity data; the list may grow over time. As discussed in UTS #35, a single unit identifier is a core unit identifier that is not composed of multiplication or division of other unit identifiers. The following steps are taken: If unitIdentifier is listed in Table 2 below, return true. Else, return false. Table 2: Single units sanctioned for use in ECMAScript Single Unit Identifier acre bit byte celsius centimeter day degree fahrenheit fluid-ounce foot gallon gigabit gigabyte gram hectare hour inch kilobit kilobyte kilogram kilometer liter megabit megabyte meter mile mile-scandinavian milliliter millimeter millisecond minute month ounce percent petabyte pound second stone terabit terabyte week yard year 7 Requirements for Standard Built-in ECMAScript Objects Unless specified otherwise in this document, the objects, functions, and constructors described in this standard are subject to the generic requirements and restrictions specified for standard built-in ECMAScript objects in the ECMAScript 2023 Language Specification (ECMA-262 14th Edition, or successor), clause 17. 8 The Intl Object The Intl object is the %Intl% intrinsic object and the initial value of the "Intl" property of the global object. The Intl object is a single ordinary object. The value of the [[Prototype]] internal slot of the Intl object is the intrinsic object %Object.prototype%. The Intl object is not a function object. It does not have a [[Construct]] internal method; it is not possible to use the Intl object as a constructor with the new operator. The Intl object does not have a [[Call]] internal method; it is not possible to invoke the Intl object as a function. The Intl object has an internal slot, [[FallbackSymbol]], which is a new %Symbol% in the current realm with the [[Description]] "IntlLegacyConstructedSymbol". 8.1 Value Properties of the Intl Object 8.1.1 Intl[ @@toStringTag ] The initial value of the @@toStringTag property is the String value "Intl". This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }. 8.2 Constructor Properties of the Intl Object With the exception of Intl.Locale, each of the following constructors is a service constructor that creates objects providing locale-sensitive services. 8.2.1 Intl.Collator ( . . . ) See 10. 8.2.2 Intl.DateTimeFormat ( . . . ) See 11. 8.2.3 Intl.DisplayNames ( . . . ) See 12. 8.2.4 Intl.ListFormat ( . . . ) See 13. 8.2.5 Intl.Locale ( . . . ) See 14. 8.2.6 Intl.NumberFormat ( . . . ) See 15. 8.2.7 Intl.PluralRules ( . . . ) See 16. 8.2.8 Intl.RelativeTimeFormat ( . . . ) See 17. 8.2.9 Intl.Segmenter ( . . . ) See 18. 8.3 Function Properties of the Intl Object 8.3.1 Intl.getCanonicalLocales ( locales ) When the getCanonicalLocales method is called with argument locales, the following steps are taken: Let ll be ? CanonicalizeLocaleList(locales). Return ! CreateArrayFromList(ll). 9 Locale and Parameter Negotiation Service constructors use a common pattern to negotiate the requests represented by their locales and options arguments against the actual capabilities of their implementations. That common behaviour is explained here in terms of internal slots describing the capabilities and abstract operations using these internal slots. 9.1 Internal slots of Service Constructors Each service constructor has the following internal slots: [[AvailableLocales]] is a List that contains structurally valid (6.2.2) and canonicalized (6.2.3) Unicode BCP 47 locale identifiers identifying the locales for which the implementation provides the functionality of the constructed objects. Language tags on the list must not have a Unicode locale extension sequence. The list must include the value returned by the DefaultLocale abstract operation (6.2.4), and must not include duplicates. Implementations must include in [[AvailableLocales]] locales that can serve as fallbacks in the algorithm used to resolve locales (see 9.2.7). For example, implementations that provide a "de-DE" locale must include a "de" locale that can serve as a fallback for requests such as "de-AT" and "de-CH". For locales that include a script subtag in addition to language and region, the corresponding locale without a script subtag must also be supported; that is, if an implementation recognizes "zh-Hant-TW", it is also expected to recognize "zh-TW". The ordering of the locales within [[AvailableLocales]] is irrelevant. [[RelevantExtensionKeys]] is a List of keys of the language tag extensions defined in Unicode Technical Standard 35 that are relevant for the functionality of the constructed objects. [[SortLocaleData]] and [[SearchLocaleData]] (for Intl.Collator) and [[LocaleData]] (for every other service constructor) are records that have fields for each locale contained in [[AvailableLocales]]. The value of each of these fields must be a record that has fields for each key contained in [[RelevantExtensionKeys]]. The value of each of these fields must be a non-empty list of those values defined in Unicode Technical Standard 35 for the given key that are supported by the implementation for the given locale, with the first element providing the default value. Note For example, an implementation of DateTimeFormat might include the language tag "th" in its [[AvailableLocales]] internal slot, and must (according to 11.2.3) include the key "ca" in its [[RelevantExtensionKeys]] internal slot. For Thai, the "buddhist" calendar is usually the default, but an implementation might also support the calendars "gregory", "chinese", and "islamicc" for the locale "th". The [[LocaleData]] internal slot would therefore at least include {[[th]]: {[[ca]]: Â« "buddhist", "gregory", "chinese", "islamicc" Â»}}. 9.2 Abstract Operations Where the following abstract operations take an availableLocales argument, it must be an [[AvailableLocales]] List as specified in 9.1. 9.2.1 CanonicalizeLocaleList ( locales ) The abstract operation CanonicalizeLocaleList takes the following steps: If locales is undefined, then Return a new empty List. Let seen be a new empty List. If Type(locales) is String or Type(locales) is Object and locales has an [[InitializedLocale]] internal slot, then Let O be ! CreateArrayFromList(Â« locales Â»). Else, Let O be ? ToObject(locales). Let len be ? ToLength(? Get(O, "length")). Let k be 0. Repeat, while k < len, Let Pk be ToString(k). Let kPresent be ? HasProperty(O, Pk). If kPresent is true, then Let kValue be ? Get(O, Pk). If Type(kValue) is not String or Object, throw a TypeError exception. If Type(kValue) is Object and kValue has an [[InitializedLocale]] internal slot, then Let tag be kValue.[[Locale]]. Else, Let tag be ? ToString(kValue). If ! IsStructurallyValidLanguageTag(tag) is false, throw a RangeError exception. Let canonicalizedTag be ! CanonicalizeUnicodeLocaleId(tag). If canonicalizedTag is not an element of seen, append canonicalizedTag as the last element of seen. Increase k by 1. Return seen. Note 1 Non-normative summary: The abstract operation interprets the locales argument as an array and copies its elements into a List, validating the elements as structurally valid language tags and canonicalizing them, and omitting duplicates. Note 2 Requiring kValue to be a String or Object means that the Number value NaN will not be interpreted as the language tag "nan", which stands for Min Nan Chinese. 9.2.2 BestAvailableLocale ( availableLocales, locale ) The BestAvailableLocale abstract operation compares the provided argument locale, which must be a String value with a structurally valid and canonicalized Unicode BCP 47 locale identifier, against the locales in availableLocales and returns either the longest non-empty prefix of locale that is an element of availableLocales, or undefined if there is no such element. It uses the fallback mechanism of RFC 4647, section 3.4. The following steps are taken: Let candidate be locale. Repeat, If availableLocales contains an element equal to candidate, return candidate. Let pos be the character index of the last occurrence of "-" (U+002D) within candidate. If that character does not occur, return undefined. If pos â‰¥ 2 and the character "-" occurs at index pos-2 of candidate, decrease pos by 2. Let candidate be the substring of candidate from position 0, inclusive, to position pos, exclusive. 9.2.3 LookupMatcher ( availableLocales, requestedLocales ) The LookupMatcher abstract operation compares requestedLocales, which must be a List as returned by CanonicalizeLocaleList, against the locales in availableLocales and determines the best available language to meet the request. The following steps are taken: Let result be a new Record. For each element locale of requestedLocales, do Let noExtensionsLocale be the String value that is locale with any Unicode locale extension sequences removed. Let availableLocale be ! BestAvailableLocale(availableLocales, noExtensionsLocale). If availableLocale is not undefined, then Set result.[[locale]] to availableLocale. If locale and noExtensionsLocale are not the same String value, then Let extension be the String value consisting of the substring of the Unicode locale extension sequence within locale. Set result.[[extension]] to extension. Return result. Let defLocale be ! DefaultLocale(). Set result.[[locale]] to defLocale. Return result. Note The algorithm is based on the Lookup algorithm described in RFC 4647 section 3.4, but options specified through Unicode locale extension sequences are ignored in the lookup. Information about such subsequences is returned separately. The abstract operation returns a record with a [[locale]] field, whose value is the language tag of the selected locale, which must be an element of availableLocales. If the language tag of the request locale that led to the selected locale contained a Unicode locale extension sequence, then the returned record also contains an [[extension]] field whose value is the substring of the Unicode locale extension sequence within the request locale language tag. 9.2.4 BestFitMatcher ( availableLocales, requestedLocales ) The BestFitMatcher abstract operation compares requestedLocales, which must be a List as returned by CanonicalizeLocaleList, against the locales in availableLocales and determines the best available language to meet the request. The algorithm is implementation dependent, but should produce results that a typical user of the requested locales would perceive as at least as good as those produced by the LookupMatcher abstract operation. Options specified through Unicode locale extension sequences must be ignored by the algorithm. Information about such subsequences is returned separately. The abstract operation returns a record with a [[locale]] field, whose value is the language tag of the selected locale, which must be an element of availableLocales. If the language tag of the request locale that led to the selected locale contained a Unicode locale extension sequence, then the returned record also contains an [[extension]] field whose value is the substring of the Unicode locale extension sequence within the request locale language tag. 9.2.5 UnicodeExtensionComponents ( extension ) The UnicodeExtensionComponents abstract operation returns the attributes and keywords from extension, which must be a String value whose contents are a Unicode locale extension sequence. If an attribute or a keyword occurs multiple times in extension, only the first occurence is returned. The following steps are taken: Let attributes be a new empty List. Let keywords be a new empty List. Let keyword be undefined. Let size be the length of extension. Let k be 3. Repeat, while k < size, Let e be ! StringIndexOf(extension, "-", k). If e = -1, let len be size - k; else let len be e - k. Let subtag be the String value equal to the substring of extension consisting of the code units at indices k (inclusive) through k + len (exclusive). If keyword is undefined and len â‰  2, then If subtag is not an element of attributes, then Append subtag to attributes. Else if len = 2, then If keyword is not undefined and keywords does not contain an element whose [[Key]] is the same as keyword.[[Key]], then Append keyword to keywords. Set keyword to the Record { [[Key]]: subtag, [[Value]]: "" }. Else, If keyword.[[Value]] is the empty String, then Set keyword.[[Value]] to subtag. Else, Set keyword.[[Value]] to the string-concatenation of keyword.[[Value]], "-", and subtag. Let k be k + len + 1. If keyword is not undefined and keywords does not contain an element whose [[Key]] is the same as keyword.[[Key]], then Append keyword to keywords. Return the Record { [[Attributes]]: attributes, [[Keywords]]: keywords }. 9.2.6 InsertUnicodeExtensionAndCanonicalize ( locale, extension ) The InsertUnicodeExtensionAndCanonicalize abstract operation inserts extension, which must be a Unicode locale extension sequence, into locale, which must be a String value with a structurally valid and canonicalized Unicode BCP 47 locale identifier. The following steps are taken: The following algorithm refers to UTS 35's Unicode Language and Locale Identifiers grammar. Assert: locale does not contain a substring that is a Unicode locale extension sequence. Assert: extension is a Unicode locale extension sequence. Assert: tag matches the unicode_locale_id production. Let privateIndex be ! StringIndexOf(locale, "-x-", 0). If privateIndex = -1, then Let locale be the string-concatenation of locale and extension. Else, Let preExtension be the substring of locale from position 0, inclusive, to position privateIndex, exclusive. Let postExtension be the substring of locale from position privateIndex to the end of the string. Let locale be the string-concatenation of preExtension, extension, and postExtension. Assert: ! IsStructurallyValidLanguageTag(locale) is true. Return ! CanonicalizeUnicodeLocaleId(locale). 9.2.7 ResolveLocale ( availableLocales, requestedLocales, options, relevantExtensionKeys, localeData ) The ResolveLocale abstract operation compares a BCP 47 language priority list requestedLocales against the locales in availableLocales and determines the best available language to meet the request. availableLocales, requestedLocales, and relevantExtensionKeys must be provided as List values, options and localeData as Records. The following steps are taken: Let matcher be options.[[localeMatcher]]. If matcher is "lookup", then Let r be ! LookupMatcher(availableLocales, requestedLocales). Else, Let r be ! BestFitMatcher(availableLocales, requestedLocales). Let foundLocale be r.[[locale]]. Let result be a new Record. Set result.[[dataLocale]] to foundLocale. If r has an [[extension]] field, then Let components be ! UnicodeExtensionComponents(r.[[extension]]). Let keywords be components.[[Keywords]]. Let supportedExtension be "-u". For each element key of relevantExtensionKeys, do Let foundLocaleData be localeData.[[<foundLocale>]]. Assert: Type(foundLocaleData) is Record. Let keyLocaleData be foundLocaleData.[[<key>]]. Assert: Type(keyLocaleData) is List. Let value be keyLocaleData[0]. Assert: Type(value) is either String or Null. Let supportedExtensionAddition be "". If r has an [[extension]] field, then If keywords contains an element whose [[Key]] is the same as key, then Let entry be the element of keywords whose [[Key]] is the same as key. Let requestedValue be entry.[[Value]]. If requestedValue is not the empty String, then If keyLocaleData contains requestedValue, then Let value be requestedValue. Let supportedExtensionAddition be the string-concatenation of "-", key, "-", and value. Else if keyLocaleData contains "true", then Let value be "true". Let supportedExtensionAddition be the string-concatenation of "-" and key. If options has a field [[<key>]], then Let optionsValue be options.[[<key>]]. Assert: Type(optionsValue) is either String, Undefined, or Null. If Type(optionsValue) is String, then Let optionsValue be the string optionsValue after performing the algorithm steps to transform Unicode extension values to canonical syntax per Unicode Technical Standard #35 LDML Â§ 3.2.1 Canonical Unicode Locale Identifiers, treating key as ukey and optionsValue as uvalue productions. Let optionsValue be the string optionsValue after performing the algorithm steps to replace Unicode extension values with their canonical form per Unicode Technical Standard #35 LDML Â§ 3.2.1 Canonical Unicode Locale Identifiers, treating key as ukey and optionsValue as uvalue productions. If optionsValue is the empty String, then Let optionsValue be "true". If keyLocaleData contains optionsValue, then If SameValue(optionsValue, value) is false, then Let value be optionsValue. Let supportedExtensionAddition be "". Set result.[[<key>]] to value. Append supportedExtensionAddition to supportedExtension. If the number of elements in supportedExtension is greater than 2, then Let foundLocale be InsertUnicodeExtensionAndCanonicalize(foundLocale, supportedExtension). Set result.[[locale]] to foundLocale. Return result. Note Non-normative summary: Two algorithms are available to match the locales: the Lookup algorithm described in RFC 4647 section 3.4, and an implementation dependent best-fit algorithm. Independent of the locale matching algorithm, options specified through Unicode locale extension sequences are negotiated separately, taking the caller's relevant extension keys and locale data as well as client-provided options into consideration. The abstract operation returns a record with a [[locale]] field whose value is the language tag of the selected locale, and fields for each key in relevantExtensionKeys providing the selected value for that key. 9.2.8 LookupSupportedLocales ( availableLocales, requestedLocales ) The LookupSupportedLocales abstract operation returns the subset of the provided BCP 47 language priority list requestedLocales for which availableLocales has a matching locale when using the BCP 47 Lookup algorithm. Locales appear in the same order in the returned list as in requestedLocales. The following steps are taken: Let subset be a new empty List. For each element locale of requestedLocales, do Let noExtensionsLocale be the String value that is locale with any Unicode locale extension sequences removed. Let availableLocale be ! BestAvailableLocale(availableLocales, noExtensionsLocale). If availableLocale is not undefined, append locale to the end of subset. Return subset. 9.2.9 BestFitSupportedLocales ( availableLocales, requestedLocales ) The BestFitSupportedLocales abstract operation returns the subset of the provided BCP 47 language priority list requestedLocales for which availableLocales has a matching locale when using the Best Fit Matcher algorithm. Locales appear in the same order in the returned list as in requestedLocales. The steps taken are implementation dependent. 9.2.10 SupportedLocales ( availableLocales, requestedLocales, options ) The SupportedLocales abstract operation returns the subset of the provided BCP 47 language priority list requestedLocales for which availableLocales has a matching locale. Two algorithms are available to match the locales: the Lookup algorithm described in RFC 4647 section 3.4, and an implementation dependent best-fit algorithm. Locales appear in the same order in the returned list as in requestedLocales. The following steps are taken: Set options to ? CoerceOptionsToObject(options). Let matcher be ? GetOption(options, "localeMatcher", "string", Â« "lookup", "best fit" Â», "best fit"). If matcher is "best fit", then Let supportedLocales be BestFitSupportedLocales(availableLocales, requestedLocales). Else, Let supportedLocales be LookupSupportedLocales(availableLocales, requestedLocales). Return ! CreateArrayFromList(supportedLocales). 9.2.11 GetOptionsObject ( options ) The abstract operation GetOptionsObject returns an Object suitable for use with GetOption, either options itself or a default empty Object. It throws a TypeError if options is not undefined and not an Object. If options is undefined, then Return ! OrdinaryObjectCreate(null). If Type(options) is Object, then Return options. Throw a TypeError exception. 9.2.12 CoerceOptionsToObject ( options ) The abstract operation CoerceOptionsToObject coerces options into an Object suitable for use with GetOption, defaulting to an empty Object. Because it coerces non-null primitive values into objects, its use is discouraged for new functionality in favour of GetOptionsObject. If options is undefined, then Return ! OrdinaryObjectCreate(null). Return ? ToObject(options). 9.2.13 GetOption ( options, property, type, values, fallback ) The abstract operation GetOption extracts the value of the property named property from the provided options object, converts it to the required type, checks whether it is one of a List of allowed values, and fills in a fallback value if necessary. If values is undefined, there is no fixed set of values and any is permitted. Assert: Type(options) is Object. Let value be ? Get(options, property). If value is undefined, return fallback. Assert: type is "boolean" or "string". If type is "boolean", then Set value to ! ToBoolean(value). If type is "string", then Set value to ? ToString(value). If values is not undefined and values does not contain an element equal to value, throw a RangeError exception. Return value. 9.2.14 DefaultNumberOption ( value, minimum, maximum, fallback ) The abstract operation DefaultNumberOption converts value to a Number value, checks whether it is in the allowed range, and fills in a fallback value if necessary. If value is undefined, return fallback. Set value to ? ToNumber(value). If value is NaN or less than minimum or greater than maximum, throw a RangeError exception. Return floor(value). 9.2.15 GetNumberOption ( options, property, minimum, maximum, fallback ) The abstract operation GetNumberOption extracts the value of the property named property from the provided options object, converts it to a Number value, checks whether it is in the allowed range, and fills in a fallback value if necessary. Assert: Type(options) is Object. Let value be ? Get(options, property). Return ? DefaultNumberOption(value, minimum, maximum, fallback). 9.2.16 PartitionPattern ( pattern ) The PartitionPattern abstract operation is called with argument pattern. This abstract operation parses an abstract pattern string into a list of Records with two fields, [[Type]] and [[Value]]. The [[Value]] field will be a String value if [[Type]] is "literal", and undefined otherwise. The syntax of the abstract pattern strings is an implementation detail and is not exposed to users of ECMA-402. The following steps are taken: Let result be a new empty List. Let beginIndex be ! StringIndexOf(pattern, "{", 0). Let endIndex be 0. Let nextIndex be 0. Let length be the number of code units in pattern. Repeat, while beginIndex is an integer index into pattern, Set endIndex to ! StringIndexOf(pattern, "}", beginIndex). Assert: endIndex is greater than beginIndex. If beginIndex is greater than nextIndex, then Let literal be a substring of pattern from position nextIndex, inclusive, to position beginIndex, exclusive. Append a new Record { [[Type]]: "literal", [[Value]]: literal } as the last element of the list result. Let p be the substring of pattern from position beginIndex, exclusive, to position endIndex, exclusive. Append a new Record { [[Type]]: p, [[Value]]: undefined } as the last element of the list result. Set nextIndex to endIndex + 1. Set beginIndex to ! StringIndexOf(pattern, "{", nextIndex). If nextIndex is less than length, then Let literal be the substring of pattern from position nextIndex, inclusive, to position length, exclusive. Append a new Record { [[Type]]: "literal", [[Value]]: literal } as the last element of the list result. Return result. 10 Collator Objects 10.1 The Intl.Collator Constructor The Intl.Collator constructor is the %Collator% intrinsic object and a standard built-in property of the Intl object. Behaviour common to all service constructor properties of the Intl object is specified in 9.1. 10.1.1 Intl.Collator ( [ locales [ , options ] ] ) When the Intl.Collator function is called with optional arguments locales and options, the following steps are taken: If NewTarget is undefined, let newTarget be the active function object, else let newTarget be NewTarget. Let internalSlotsList be Â« [[InitializedCollator]], [[Locale]], [[Usage]], [[Sensitivity]], [[IgnorePunctuation]], [[Collation]], [[BoundCompare]] Â». If %Collator%.[[RelevantExtensionKeys]] contains "kn", then Append [[Numeric]] as the last element of internalSlotsList. If %Collator%.[[RelevantExtensionKeys]] contains "kf", then Append [[CaseFirst]] as the last element of internalSlotsList. Let collator be ? OrdinaryCreateFromConstructor(newTarget, "%Collator.prototype%", internalSlotsList). Return ? InitializeCollator(collator, locales, options). 10.1.2 InitializeCollator ( collator, locales, options ) The abstract operation InitializeCollator accepts the arguments collator (which must be an object), locales, and options. It initializes collator as a Collator object. The following steps are taken: The following algorithm refers to the type nonterminal from UTS 35's Unicode Locale Identifier grammar. Let requestedLocales be ? CanonicalizeLocaleList(locales). Set options to ? CoerceOptionsToObject(options). Let usage be ? GetOption(options, "usage", "string", Â« "sort", "search" Â», "sort"). Set collator.[[Usage]] to usage. If usage is "sort", then Let localeData be %Collator%.[[SortLocaleData]]. Else, Let localeData be %Collator%.[[SearchLocaleData]]. Let opt be a new Record. Let matcher be ? GetOption(options, "localeMatcher", "string", Â« "lookup", "best fit" Â», "best fit"). Set opt.[[localeMatcher]] to matcher. Let collation be ? GetOption(options, "collation", "string", undefined, undefined). If collation is not undefined, then If collation does not match the Unicode Locale Identifier type nonterminal, throw a RangeError exception. Set opt.[[co]] to collation. Let numeric be ? GetOption(options, "numeric", "boolean", undefined, undefined). If numeric is not undefined, then Let numeric be ! ToString(numeric). Set opt.[[kn]] to numeric. Let caseFirst be ? GetOption(options, "caseFirst", "string", Â« "upper", "lower", "false" Â», undefined). Set opt.[[kf]] to caseFirst. Let relevantExtensionKeys be %Collator%.[[RelevantExtensionKeys]]. Let r be ResolveLocale(%Collator%.[[AvailableLocales]], requestedLocales, opt, relevantExtensionKeys, localeData). Set collator.[[Locale]] to r.[[locale]]. Let collation be r.[[co]]. If collation is null, let collation be "default". Set collator.[[Collation]] to collation. If relevantExtensionKeys contains "kn", then Set collator.[[Numeric]] to ! SameValue(r.[[kn]], "true"). If relevantExtensionKeys contains "kf", then Set collator.[[CaseFirst]] to r.[[kf]]. Let sensitivity be ? GetOption(options, "sensitivity", "string", Â« "base", "accent", "case", "variant" Â», undefined). If sensitivity is undefined, then If usage is "sort", then Let sensitivity be "variant". Else, Let dataLocale be r.[[dataLocale]]. Let dataLocaleData be localeData.[[<dataLocale>]]. Let sensitivity be dataLocaleData.[[sensitivity]]. Set collator.[[Sensitivity]] to sensitivity. Let ignorePunctuation be ? GetOption(options, "ignorePunctuation", "boolean", undefined, false). Set collator.[[IgnorePunctuation]] to ignorePunctuation. Return collator. 10.2 Properties of the Intl.Collator Constructor The Intl.Collator constructor has the following properties: 10.2.1 Intl.Collator.prototype The value of Intl.Collator.prototype is %Collator.prototype%. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 10.2.2 Intl.Collator.supportedLocalesOf ( locales [ , options ] ) When the supportedLocalesOf method is called with arguments locales and options, the following steps are taken: Let availableLocales be %Collator%.[[AvailableLocales]]. Let requestedLocales be ? CanonicalizeLocaleList(locales). Return ? SupportedLocales(availableLocales, requestedLocales, options). 10.2.3 Internal slots The value of the [[AvailableLocales]] internal slot is implementation-defined within the constraints described in 9.1. The value of the [[RelevantExtensionKeys]] internal slot is a List that must include the element "co", may include any or all of the elements "kf" and "kn", and must not include any other elements. Note Unicode Technical Standard 35 describes ten locale extension keys that are relevant to collation: "co" for collator usage and specializations, "ka" for alternate handling, "kb" for backward second level weight, "kc" for case level, "kf" for case first, "kh" for hiragana quaternary, "kk" for normalization, "kn" for numeric, "kr" for reordering, "ks" for collation strength, and "vt" for variable top. Collator, however, requires that the usage is specified through the "usage" property of the options object, alternate handling through the "ignorePunctuation" property of the options object, and case level and the strength through the "sensitivity" property of the options object. The "co" key in the language tag is supported only for collator specializations, and the keys "kb", "kh", "kk", "kr", and "vt" are not allowed in this version of the Internationalization API. Support for the remaining keys is implementation dependent. The values of the [[SortLocaleData]] and [[SearchLocaleData]] internal slots are implementation-defined within the constraints described in 9.1 and the following additional constraints, for all locale values locale: The first element of [[SortLocaleData]].[[<locale>]].[[co]] and [[SearchLocaleData]].[[<locale>]].[[co]] must be null. The values "standard" and "search" must not be used as elements in any [[SortLocaleData]].[[<locale>]].[[co]] and [[SearchLocaleData]].[[<locale>]].[[co]] list. [[SearchLocaleData]].[[<locale>]] must have a [[sensitivity]] field with a String value equal to "base", "accent", "case", or "variant". 10.3 Properties of the Intl.Collator Prototype Object The Intl.Collator prototype object is itself an ordinary object. %Collator.prototype% is not an Intl.Collator instance and does not have an [[InitializedCollator]] internal slot or any of the other internal slots of Intl.Collator instance objects. 10.3.1 Intl.Collator.prototype.constructor The initial value of Intl.Collator.prototype.constructor is %Collator%. 10.3.2 Intl.Collator.prototype [ @@toStringTag ] The initial value of the @@toStringTag property is the String value "Intl.Collator". This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }. 10.3.3 get Intl.Collator.prototype.compare This named accessor property returns a function that compares two strings according to the sort order of this Collator object. Intl.Collator.prototype.compare is an accessor property whose set accessor function is undefined. Its get accessor function performs the following steps: Let collator be the this value. Perform ? RequireInternalSlot(collator, [[InitializedCollator]]). If collator.[[BoundCompare]] is undefined, then Let F be a new built-in function object as defined in 10.3.3.1. Set F.[[Collator]] to collator. Set collator.[[BoundCompare]] to F. Return collator.[[BoundCompare]]. Note The returned function is bound to collator so that it can be passed directly to Array.prototype.sort or other functions. 10.3.3.1 Collator Compare Functions A Collator compare function is an anonymous built-in function that has a [[Collator]] internal slot. When a Collator compare function F is called with arguments x and y, the following steps are taken: Let collator be F.[[Collator]]. Assert: Type(collator) is Object and collator has an [[InitializedCollator]] internal slot. If x is not provided, let x be undefined. If y is not provided, let y be undefined. Let X be ? ToString(x). Let Y be ? ToString(y). Return CompareStrings(collator, X, Y). The "length" property of a Collator compare function is 2. 10.3.3.2 CompareStrings ( collator, x, y ) When the CompareStrings abstract operation is called with arguments collator (which must be an object initialized as a Collator), x and y (which must be String values), it returns a Number other than NaN that represents the result of a locale-sensitive String comparison of x with y. The two Strings are compared in an implementation-defined fashion. The result is intended to order String values in the sort order specified by the effective locale and collation options computed during construction of collator, and will be negative, zero, or positive, depending on whether x comes before y in the sort order, the Strings are equal under the sort order, or x comes after y in the sort order, respectively. String values must be interpreted as UTF-16 code unit sequences, and a surrogate pair (a code unit in the range 0xD800 to 0xDBFF followed by a code unit in the range 0xDC00 to 0xDFFF) within a string must be interpreted as the corresponding code point. The sensitivity of collator is interpreted as follows: base: Only strings that differ in base letters compare as unequal. Examples: a â‰  b, a = Ã¡, a = A. accent: Only strings that differ in base letters or accents and other diacritic marks compare as unequal. Examples: a â‰  b, a â‰  Ã¡, a = A. case: Only strings that differ in base letters or case compare as unequal. Examples: a â‰  b, a = Ã¡, a â‰  A. variant: Strings that differ in base letters, accents and other diacritic marks, or case compare as unequal. Other differences may also be taken into consideration. Examples: a â‰  b, a â‰  Ã¡, a â‰  A. Note 1 In some languages, certain letters with diacritic marks are considered base letters. For example, in Swedish, "Ã¶" is a base letter that's different from "o". If the collator is set to ignore punctuation, then strings that differ only in punctuation compare as equal. For the interpretation of options settable through extension keys, see Unicode Technical Standard 35. The CompareStrings abstract operation with any given collator argument, if considered as a function of the remaining two arguments x and y, must be a consistent comparison function (as defined in es2023, 22.1.3.27) on the set of all Strings. The actual return values are implementation-defined to permit implementers to encode additional information in the value. The method is required to return +0ð?”½ when comparing Strings that are considered canonically equivalent by the Unicode Standard. Note 2 It is recommended that the CompareStrings abstract operation be implemented following Unicode Technical Standard 10, Unicode Collation Algorithm (available at https://unicode.org/reports/tr10/), using tailorings for the effective locale and collation options of collator. It is recommended that implementations use the tailorings provided by the Common Locale Data Repository (available at https://cldr.unicode.org/). Note 3 Applications should not assume that the behaviour of the CompareStrings abstract operation for Collator instances with the same resolved options will remain the same for different versions of the same implementation. 10.3.4 Intl.Collator.prototype.resolvedOptions ( ) This function provides access to the locale and options computed during initialization of the object. Let collator be the this value. Perform ? RequireInternalSlot(collator, [[InitializedCollator]]). Let options be ! OrdinaryObjectCreate(%Object.prototype%). For each row of Table 3, except the header row, in table order, do Let p be the Property value of the current row. Let v be the value of collator's internal slot whose name is the Internal Slot value of the current row. If the current row has an Extension Key value, then Let extensionKey be the Extension Key value of the current row. If %Collator%.[[RelevantExtensionKeys]] does not contain extensionKey, then Let v be undefined. If v is not undefined, then Perform ! CreateDataPropertyOrThrow(options, p, v). Return options. Table 3: Resolved Options of Collator Instances Internal Slot Property Extension Key [[Locale]] "locale" [[Usage]] "usage" [[Sensitivity]] "sensitivity" [[IgnorePunctuation]] "ignorePunctuation" [[Collation]] "collation" [[Numeric]] "numeric" "kn" [[CaseFirst]] "caseFirst" "kf" 10.4 Properties of Intl.Collator Instances Intl.Collator instances are ordinary objects that inherit properties from %Collator.prototype%. Intl.Collator instances have an [[InitializedCollator]] internal slot. Intl.Collator instances also have several internal slots that are computed by the constructor: [[Locale]] is a String value with the language tag of the locale whose localization is used for collation. [[Usage]] is one of the String values "sort" or "search", identifying the collator usage. [[Sensitivity]] is one of the String values "base", "accent", "case", or "variant", identifying the collator's sensitivity. [[IgnorePunctuation]] is a Boolean value, specifying whether punctuation should be ignored in comparisons. [[Collation]] is a String value with the "type" given in Unicode Technical Standard 35 for the collation, except that the values "standard" and "search" are not allowed, while the value "default" is allowed. Intl.Collator instances also have the following internal slots if the key corresponding to the name of the internal slot in Table 3 is included in the [[RelevantExtensionKeys]] internal slot of Intl.Collator: [[Numeric]] is a Boolean value, specifying whether numeric sorting is used. [[CaseFirst]] is one of the String values "upper", "lower", or "false". Finally, Intl.Collator instances have a [[BoundCompare]] internal slot that caches the function returned by the compare accessor (10.3.3). 11 DateTimeFormat Objects 11.1 The Intl.DateTimeFormat Constructor The Intl.DateTimeFormat constructor is the %DateTimeFormat% intrinsic object and a standard built-in property of the Intl object. Behaviour common to all service constructor properties of the Intl object is specified in 9.1. 11.1.1 Intl.DateTimeFormat ( [ locales [ , options ] ] ) When the Intl.DateTimeFormat function is called with optional arguments locales and options, the following steps are taken: If NewTarget is undefined, let newTarget be the active function object, else let newTarget be NewTarget. Let dateTimeFormat be ? OrdinaryCreateFromConstructor(newTarget, "%DateTimeFormat.prototype%", Â« [[InitializedDateTimeFormat]], [[Locale]], [[Calendar]], [[NumberingSystem]], [[TimeZone]], [[Weekday]], [[Era]], [[Year]], [[Month]], [[Day]], [[DayPeriod]], [[Hour]], [[Minute]], [[Second]], [[FractionalSecondDigits]], [[TimeZoneName]], [[HourCycle]], [[Pattern]], [[BoundFormat]] Â»). Perform ? InitializeDateTimeFormat(dateTimeFormat, locales, options). If the implementation supports the normative optional constructor mode of 4.3 Note 1, then Let this be the this value. Return ? ChainDateTimeFormat(dateTimeFormat, NewTarget, this). Return dateTimeFormat. 11.1.1.1 ChainDateTimeFormat ( dateTimeFormat, newTarget, this ) If newTarget is undefined and ? OrdinaryHasInstance(%DateTimeFormat%, this) is true, then Perform ? DefinePropertyOrThrow(this, %Intl%.[[FallbackSymbol]], PropertyDescriptor{ [[Value]]: dateTimeFormat, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }). Return this. Return dateTimeFormat. 11.1.2 InitializeDateTimeFormat ( dateTimeFormat, locales, options ) The abstract operation InitializeDateTimeFormat accepts the arguments dateTimeFormat (which must be an object), locales, and options. It initializes dateTimeFormat as a DateTimeFormat object. This abstract operation functions as follows: The following algorithm refers to the type nonterminal from UTS 35's Unicode Locale Identifier grammar. Let requestedLocales be ? CanonicalizeLocaleList(locales). Set options to ? ToDateTimeOptions(options, "any", "date"). Let opt be a new Record. Let matcher be ? GetOption(options, "localeMatcher", "string", Â« "lookup", "best fit" Â», "best fit"). Set opt.[[localeMatcher]] to matcher. Let calendar be ? GetOption(options, "calendar", "string", undefined, undefined). If calendar is not undefined, then If calendar does not match the Unicode Locale Identifier type nonterminal, throw a RangeError exception. Set opt.[[ca]] to calendar. Let numberingSystem be ? GetOption(options, "numberingSystem", "string", undefined, undefined). If numberingSystem is not undefined, then If numberingSystem does not match the Unicode Locale Identifier type nonterminal, throw a RangeError exception. Set opt.[[nu]] to numberingSystem. Let hour12 be ? GetOption(options, "hour12", "boolean", undefined, undefined). Let hourCycle be ? GetOption(options, "hourCycle", "string", Â« "h11", "h12", "h23", "h24" Â», undefined). If hour12 is not undefined, then Set hourCycle to null. Set opt.[[hc]] to hourCycle. Let localeData be %DateTimeFormat%.[[LocaleData]]. Let r be ResolveLocale(%DateTimeFormat%.[[AvailableLocales]], requestedLocales, opt, %DateTimeFormat%.[[RelevantExtensionKeys]], localeData). Set dateTimeFormat.[[Locale]] to r.[[locale]]. Set calendar to r.[[ca]]. Set dateTimeFormat.[[Calendar]] to calendar. Set dateTimeFormat.[[NumberingSystem]] to r.[[nu]]. Let dataLocale be r.[[dataLocale]]. Let dataLocaleData be localeData.[[<dataLocale>]]. Let hcDefault be dataLocaleData.[[hourCycle]]. If r.[[hc]] is null, then Let hc be hcDefault. If hour12 is true, then If hcDefault is "h11" or "h23", then Let hc be "h11". Else, Let hc be "h12". Else if hour12 is false, then If hcDefault is "h11" or "h23", then Let hc be "h23". Else, Let hc be "h24". Else, Let hc be r.[[hc]]. Assert: hour12 is undefined. Set dateTimeFormat.[[HourCycle]] to hc. Let formatOptions be a new Record. Set formatOptions.[[hourCycle]] to hc. Let timeZone be ? Get(options, "timeZone"). If timeZone is undefined, then Set timeZone to ! DefaultTimeZone(). Else, Set timeZone to ? ToString(timeZone). If the result of ! IsValidTimeZoneName(timeZone) is false, then Throw a RangeError exception. Set timeZone to ! CanonicalizeTimeZoneName(timeZone). Set dateTimeFormat.[[TimeZone]] to timeZone. Let hasExplicitFormatComponents be false. For each row of Table 6, except the header row, in table order, do Let prop be the name given in the Property column of the row. If prop is "fractionalSecondDigits", then Let value be ? GetNumberOption(options, "fractionalSecondDigits", 1, 3, undefined). Else, Let values be a List whose elements are the strings given in the Values column of the row. Let value be ? GetOption(options, prop, "string", values, undefined). Set formatOptions.[[<prop>]] to value. If value is not undefined, then Set hasExplicitFormatComponents to true. Let matcher be ? GetOption(options, "formatMatcher", "string", Â« "basic", "best fit" Â», "best fit"). Let dateStyle be ? GetOption(options, "dateStyle", "string", Â« "full", "long", "medium", "short" Â», undefined). Set dateTimeFormat.[[DateStyle]] to dateStyle. Let timeStyle be ? GetOption(options, "timeStyle", "string", Â« "full", "long", "medium", "short" Â», undefined). Set dateTimeFormat.[[TimeStyle]] to timeStyle. If dateStyle is not undefined or timeStyle is not undefined, then If hasExplicitFormatComponents is true, then Throw a TypeError exception. Let styles be dataLocaleData.[[styles]].[[<calendar>]]. Let bestFormat be DateTimeStyleFormat(dateStyle, timeStyle, styles). Else, Let formats be dataLocaleData.[[formats]].[[<calendar>]]. If matcher is "basic", then Let bestFormat be BasicFormatMatcher(formatOptions, formats). Else, Let bestFormat be BestFitFormatMatcher(formatOptions, formats). For each row in Table 6, except the header row, in table order, do Let prop be the name given in the Property column of the row. If bestFormat has a field [[<prop>]], then Let p be bestFormat.[[<prop>]]. Set dateTimeFormat's internal slot whose name is the Internal Slot column of the row to p. If dateTimeFormat.[[Hour]] is undefined, then Set dateTimeFormat.[[HourCycle]] to undefined. If dateTimeformat.[[HourCycle]] is "h11" or "h12", then Let pattern be bestFormat.[[pattern12]]. Let rangePatterns be bestFormat.[[rangePatterns12]]. Else, Let pattern be bestFormat.[[pattern]]. Let rangePatterns be bestFormat.[[rangePatterns]]. Set dateTimeFormat.[[Pattern]] to pattern. Set dateTimeFormat.[[RangePatterns]] to rangePatterns. Return dateTimeFormat. 11.2 Properties of the Intl.DateTimeFormat Constructor The Intl.DateTimeFormat constructor has the following properties: 11.2.1 Intl.DateTimeFormat.prototype The value of Intl.DateTimeFormat.prototype is %DateTimeFormat.prototype%. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 11.2.2 Intl.DateTimeFormat.supportedLocalesOf ( locales [ , options ] ) When the supportedLocalesOf method is called with arguments locales and options, the following steps are taken: Let availableLocales be %DateTimeFormat%.[[AvailableLocales]]. Let requestedLocales be ? CanonicalizeLocaleList(locales). Return ? SupportedLocales(availableLocales, requestedLocales, options). 11.2.3 Internal slots The value of the [[AvailableLocales]] internal slot is implementation-defined within the constraints described in 9.1. The value of the [[RelevantExtensionKeys]] internal slot is Â« "ca", "hc", "nu" Â». Note 1 Unicode Technical Standard 35 describes four locale extension keys that are relevant to date and time formatting: "ca" for calendar, "hc" for hour cycle, "nu" for numbering system (of formatted numbers), and "tz" for time zone. DateTimeFormat, however, requires that the time zone is specified through the "timeZone" property in the options objects. The value of the [[LocaleData]] internal slot is implementation-defined within the constraints described in 9.1 and the following additional constraints, for all locale values locale: [[LocaleData]].[[<locale>]].[[nu]] must be a List that does not include the values "native", "traditio", or "finance". [[LocaleData]].[[<locale>]].[[hc]] must be Â« null, "h11", "h12", "h23", "h24" Â». [[LocaleData]].[[<locale>]].[[hourCycle]] must be a String value equal to "h11", "h12", "h23", or "h24". [[LocaleData]].[[<locale>]] must have a [[formats]] field. This [[formats]] field must be a Record with [[<calendar>]] fields for all calendar values calendar. The value of this field must be a list of records, each of which has a subset of the fields shown in Table 6, where each field must have one of the values specified for the field in Table 6. Multiple records in a list may use the same subset of the fields as long as they have different values for the fields. The following subsets must be available for each locale: weekday, year, month, day, hour, minute, second, fractionalSecondDigits weekday, year, month, day, hour, minute, second weekday, year, month, day year, month, day year, month month, day hour, minute, second, fractionalSecondDigits hour, minute, second hour, minute dayPeriod, hour dayPeriod, hour, minute, second dayPeriod, hour, minute Each of the records must also have the following fields: A [[pattern]] field, whose value is a String value that contains for each of the date and time format component fields of the record a substring starting with "{", followed by the name of the field, followed by "}". If the record has an [[hour]] field, it must also have a [[pattern12]] field, whose value is a String value that, in addition to the substrings of the [[pattern]] field, contains at least one of the substrings "{ampm}" or "{dayPeriod}". If the record has a [[year]] field, the [[pattern]] and [[pattern12]] values may contain the substrings "{yearName}" and "{relatedYear}". A [[rangePatterns]] field with a Record value: The [[rangePatterns]] record may have any of the fields in Table 4, where each field represents a range pattern and its value is a Record. The name of the field indicates the largest calendar element that must be different between the start and end dates in order to use this range pattern. For example, if the field name is [[Month]], it contains the range pattern that should be used to format a date range where the era and year values are the same, but the month value is different. The record will contain the following fields: A subset of the fields shown in the Property column of Table 6, where each field must have one of the values specified for that field in the Values column of Table 6. All fields required to format a date for any of the [[PatternParts]] records must be present. A [[PatternParts]] field whose value is a list of Records each representing a part of the range pattern. Each record contains a [[Pattern]] field and a [[Source]] field. The [[Pattern]] field's value is a String of the same format as the regular date pattern String. The [[Source]] field is one of the String values "shared", "startRange", or "endRange". It indicates which of the range's dates should be formatted using the value of the [[Pattern]] field. The [[rangePatterns]] record must have a [[Default]] field which contains the default range pattern used when the specific range pattern is not available. Its value is a list of records with the same structure as the other fields in the [[rangePatterns]] record. If the record has an [[hour]] field, it must also have a [[rangePatterns12]] field. Its value is similar to the Record in [[rangePatterns]], but it uses a String similar to [[pattern12]] for each part of the range pattern. If the record has a [[year]] field, the [[rangePatterns]] and [[rangePatterns12]] fields may contain range patterns where the [[Pattern]] values may contain the substrings "{yearName}" and "{relatedYear}". [[LocaleData]].[[<locale>]] must have a [[styles]] field. The [[styles]] field must be a Record with [[<calendar>]] fields for all calendar values calendar. The calendar records must contain [[DateFormat]], [[TimeFormat]], [[DateTimeFormat]] and [[DateTimeRangeFormat]] fields, the value of these fields are Records, where each of which has [[full]], [[long]], [[medium]] and [[short]] fields. For [[DateFormat]] and [[TimeFormat]], the value of these fields must be a record, which has a subset of the fields shown in Table 6, where each field must have one of the values specified for the field in Table 6. Each of the records must also have the following fields: A [[pattern]] field, whose value is a String value that contains for each of the date and time format component fields of the record a substring starting with "{", followed by the name of the field, followed by "}". If the record has an [[hour]] field, it must also have a [[pattern12]] field, whose value is a String value that, in addition to the substrings of the pattern field, contains at least one of the substrings "{ampm}" or "{dayPeriod}". A [[rangePatterns]] field that contains a record similar to the one described in the [[formats]] field. If the record has an [[hour]] field, it must also have a [[rangePatterns12]] field. Its value is similar to the record in [[rangePatterns]] but it uses a string similar to [[pattern12]] for each range pattern. For [[DateTimeFormat]], the field value must be a string pattern which contains the strings "{0}" and "{1}". For [[DateTimeRangeFormat]] the value of these fields must be a nested record which also has [[full]], [[long]], [[medium]] and [[short]] fields. The [[full]], [[long]], [[medium]] and [[short]] fields in the enclosing record refer to the date style of the range pattern, while the fields in the nested record refers to the time style of the range pattern. The value of these fields in the nested record is a record with a [[rangePatterns]] field and a [[rangePatterns12]] field which are similar to the [[rangePatterns]] and [rangePatterns12]] fields in [[DateFormat]] and [[TimeFormat]]. Note 2 For example, an implementation might include the following record as part of its English locale data: [[hour]]: "numeric" [[minute]]: "numeric" [[pattern]]: "{hour}:{minute}" [[pattern12]]: "{hour}:{minute} {ampm}" [[rangePatterns]]: [[Hour]]: [[hour]]: "numeric" [[minute]]: "numeric" [[PatternParts]]: {[[Source]]: "startRange", [[Pattern]]: "{hour}:{minute}"} {[[Source]]: "shared", [[Pattern]]: " â€“ "} {[[Source]]: "endRange", [[Pattern]]: "{hour}:{minute}"} [[Minute]]: [[hour]]: "numeric" [[minute]]: "numeric" [[PatternParts]]: {[[Source]]: "startRange", [[Pattern]]: "{hour}:{minute}"} {[[Source]]: "shared", [[Pattern]]: " â€“ "} {[[Source]]: "endRange", [[Pattern]]: "{hour}:{minute}"} [[Default]]: [[year]]: "2-digit" [[month]]: "numeric" [[day]]: "numeric" [[hour]]: "numeric" [[minute]]: "numeric" [[PatternParts]]: {[[Source]]: "startRange", [[Pattern]]: "{day}/{month}/{year}, {hour}:{minute}"} {[[Source]]: "shared", [[Pattern]]: " â€“ "} {[[Source]]: "endRange", [[Pattern]]: "{day}/{month}/{year}, {hour}:{minute}"} [[rangePatterns12]]: [[Hour]]: [[hour]]: "numeric" [[minute]]: "numeric" [[PatternParts]]: {[[Source]]: "startRange", [[Pattern]]: "{hour}:{minute}"} {[[Source]]: "shared", [[Pattern]]: " â€“ "} {[[Source]]: "endRange", [[Pattern]]: "{hour}:{minute}"} {[[Source]]: "shared", [[Pattern]]: " {ampm}"} [[Minute]]: [[hour]]: "numeric" [[minute]]: "numeric" [[PatternParts]]: {[[Source]]: "startRange", [[Pattern]]: "{hour}:{minute}"} {[[Source]]: "shared", [[Pattern]]: " â€“ "} {[[Source]]: "endRange", [[Pattern]]: "{hour}:{minute}"} {[[Source]]: "shared", [[Pattern]]: " {ampm}"} [[Default]]: [[year]]: "2-digit" [[month]]: "numeric" [[day]]: "numeric" [[hour]]: "numeric" [[minute]]: "numeric" [[PatternParts]]: {[[Source]]: "startRange", [[Pattern]]: "{day}/{month}/{year}, {hour}:{minute} {ampm}"} {[[Source]]: "shared", [[Pattern]]: " â€“ "} {[[Source]]: "endRange", [[Pattern]]: "{day}/{month}/{year}, {hour}:{minute} {ampm}"} Note 3 It is recommended that implementations use the locale data provided by the Common Locale Data Repository (available at https://cldr.unicode.org/). Table 4: Range pattern fields Range Pattern Field Pattern String Field [[Era]] "era" [[Year]] "year" [[Month]] "month" [[Day]] "day" [[AmPm]] "ampm" [[DayPeriod]] "dayPeriod" [[Hour]] "hour" [[Minute]] "minute" [[Second]] "second" [[FractionalSecondDigits]] "fractionalSecondDigits" 11.3 Properties of the Intl.DateTimeFormat Prototype Object The Intl.DateTimeFormat prototype object is itself an ordinary object. %DateTimeFormat.prototype% is not an Intl.DateTimeFormat instance and does not have an [[InitializedDateTimeFormat]] internal slot or any of the other internal slots of Intl.DateTimeFormat instance objects. 11.3.1 Intl.DateTimeFormat.prototype.constructor The initial value of Intl.DateTimeFormat.prototype.constructor is %DateTimeFormat%. 11.3.2 Intl.DateTimeFormat.prototype [ @@toStringTag ] The initial value of the @@toStringTag property is the String value "Intl.DateTimeFormat". This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }. 11.3.3 get Intl.DateTimeFormat.prototype.format Intl.DateTimeFormat.prototype.format is an accessor property whose set accessor function is undefined. Its get accessor function performs the following steps: Let dtf be the this value. If the implementation supports the normative optional constructor mode of 4.3 Note 1, then Set dtf to ? UnwrapDateTimeFormat(dtf). Perform ? RequireInternalSlot(dtf, [[InitializedDateTimeFormat]]). If dtf.[[BoundFormat]] is undefined, then Let F be a new built-in function object as defined in DateTime Format Functions (11.5.5). Set F.[[DateTimeFormat]] to dtf. Set dtf.[[BoundFormat]] to F. Return dtf.[[BoundFormat]]. Note The returned function is bound to dtf so that it can be passed directly to Array.prototype.map or other functions. This is considered a historical artefact, as part of a convention which is no longer followed for new features, but is preserved to maintain compatibility with existing programs. 11.3.4 Intl.DateTimeFormat.prototype.formatToParts ( date ) When the formatToParts method is called with an argument date, the following steps are taken: Let dtf be the this value. Perform ? RequireInternalSlot(dtf, [[InitializedDateTimeFormat]]). If date is undefined, then Let x be ! Call(%Date.now%, undefined). Else, Let x be ? ToNumber(date). Return ? FormatDateTimeToParts(dtf, x). 11.3.5 Intl.DateTimeFormat.prototype.formatRange ( startDate, endDate ) When the formatRange method is called with arguments startDate and endDate, the following steps are taken: Let dtf be this value. Perform ? RequireInternalSlot(dtf, [[InitializedDateTimeFormat]]). If startDate is undefined or endDate is undefined, throw a TypeError exception. Let x be ? ToNumber(startDate). Let y be ? ToNumber(endDate). Return ? FormatDateTimeRange(dtf, x, y). 11.3.6 Intl.DateTimeFormat.prototype.formatRangeToParts ( startDate, endDate ) When the formatRangeToParts method is called with arguments startDate and endDate, the following steps are taken: Let dtf be this value. Perform ? RequireInternalSlot(dtf, [[InitializedDateTimeFormat]]). If startDate is undefined or endDate is undefined, throw a TypeError exception. Let x be ? ToNumber(startDate). Let y be ? ToNumber(endDate). Return ? FormatDateTimeRangeToParts(dtf, x, y). 11.3.7 Intl.DateTimeFormat.prototype.resolvedOptions ( ) This function provides access to the locale and options computed during initialization of the object. Let dtf be the this value. If the implementation supports the normative optional constructor mode of 4.3 Note 1, then Set dtf to ? UnwrapDateTimeFormat(dtf). Perform ? RequireInternalSlot(dtf, [[InitializedDateTimeFormat]]). Let options be ! OrdinaryObjectCreate(%Object.prototype%). For each row of Table 5, except the header row, in table order, do Let p be the Property value of the current row. If p is "hour12", then Let hc be dtf.[[HourCycle]]. If hc is "h11" or "h12", let v be true. Else if, hc is "h23" or "h24", let v be false. Else, let v be undefined. Else, Let v be the value of dtf's internal slot whose name is the Internal Slot value of the current row. If the Internal Slot value of the current row is an Internal Slot value in Table 6, then If dtf.[[DateStyle]] is not undefined or dtf.[[TimeStyle]] is not undefined, then Let v be undefined. If v is not undefined, then Perform ! CreateDataPropertyOrThrow(options, p, v). Return options. Table 5: Resolved Options of DateTimeFormat Instances Internal Slot Property [[Locale]] "locale" [[Calendar]] "calendar" [[NumberingSystem]] "numberingSystem" [[TimeZone]] "timeZone" [[HourCycle]] "hourCycle" "hour12" [[Weekday]] "weekday" [[Era]] "era" [[Year]] "year" [[Month]] "month" [[Day]] "day" [[DayPeriod]] "dayPeriod" [[Hour]] "hour" [[Minute]] "minute" [[Second]] "second" [[FractionalSecondDigits]] "fractionalSecondDigits" [[TimeZoneName]] "timeZoneName" [[DateStyle]] "dateStyle" [[TimeStyle]] "timeStyle" For web compatibility reasons, if the property "hourCycle" is set, the "hour12" property should be set to true when "hourCycle" is "h11" or "h12", or to false when "hourCycle" is "h23" or "h24". Note 1 In this version of the ECMAScript 2023 Internationalization API, the "timeZone" property will be the name of the default time zone if no "timeZone" property was provided in the options object provided to the Intl.DateTimeFormat constructor. The first edition left the "timeZone" property undefined in this case. Note 2 For compatibility with versions prior to the fifth edition, the "hour12" property is set in addition to the "hourCycle" property. 11.4 Properties of Intl.DateTimeFormat Instances Intl.DateTimeFormat instances are ordinary objects that inherit properties from %DateTimeFormat.prototype%. Intl.DateTimeFormat instances have an [[InitializedDateTimeFormat]] internal slot. Intl.DateTimeFormat instances also have several internal slots that are computed by the constructor: [[Locale]] is a String value with the language tag of the locale whose localization is used for formatting. [[Calendar]] is a String value with the "type" given in Unicode Technical Standard 35 for the calendar used for formatting. [[NumberingSystem]] is a String value with the "type" given in Unicode Technical Standard 35 for the numbering system used for formatting. [[TimeZone]] is a String value with the IANA time zone name of the time zone used for formatting. [[Weekday]], [[Era]], [[Year]], [[Month]], [[Day]], [[DayPeriod]], [[Hour]], [[Minute]], [[Second]], [[TimeZoneName]] are each either undefined, indicating that the component is not used for formatting, or one of the String values given in Table 6, indicating how the component should be presented in the formatted output. [[FractionalSecondDigits]] is either undefined or a positive, non-zero integer Number value indicating the fraction digits to be used for fractional seconds. Numbers will be rounded or padded with trailing zeroes if necessary. [[HourCycle]] is a String value indicating whether the 12-hour format ("h11", "h12") or the 24-hour format ("h23", "h24") should be used. "h11" and "h23" start with hour 0 and go up to 11 and 23 respectively. "h12" and "h24" start with hour 1 and go up to 12 and 24. [[HourCycle]] is only used when [[Hour]] is not undefined. [[DateStyle]], [[TimeStyle]] are each either undefined, or a String value with values "full", "long", "medium", or "short". [[Pattern]] is a String value as described in 11.2.3. [[RangePatterns]] is a Record as described in 11.2.3. Finally, Intl.DateTimeFormat instances have a [[BoundFormat]] internal slot that caches the function returned by the format accessor (11.3.3). 11.5 Abstract Operations for DateTimeFormat Objects Several DateTimeFormat algorithms use values from the following table, which provides internal slots, property names and allowable values for the components of date and time formats: Table 6: Components of date and time formats Internal Slot Property Values [[Weekday]] "weekday" "narrow", "short", "long" [[Era]] "era" "narrow", "short", "long" [[Year]] "year" "2-digit", "numeric" [[Month]] "month" "2-digit", "numeric", "narrow", "short", "long" [[Day]] "day" "2-digit", "numeric" [[DayPeriod]] "dayPeriod" "narrow", "short", "long" [[Hour]] "hour" "2-digit", "numeric" [[Minute]] "minute" "2-digit", "numeric" [[Second]] "second" "2-digit", "numeric" [[FractionalSecondDigits]] "fractionalSecondDigits" 1ð?”½, 2ð?”½, 3ð?”½ [[TimeZoneName]] "timeZoneName" "short", "long", "shortOffset", "longOffset", "shortGeneric", "longGeneric" 11.5.1 ToDateTimeOptions ( options, required, defaults ) When the ToDateTimeOptions abstract operation is called with arguments options, required, and defaults, the following steps are taken: If options is undefined, let options be null; otherwise let options be ? ToObject(options). Let options be ! OrdinaryObjectCreate(options). Let needDefaults be true. If required is "date" or "any", then For each property name prop of Â« "weekday", "year", "month", "day" Â», do Let value be ? Get(options, prop). If value is not undefined, let needDefaults be false. If required is "time" or "any", then For each property name prop of Â« "dayPeriod", "hour", "minute", "second", "fractionalSecondDigits" Â», do Let value be ? Get(options, prop). If value is not undefined, let needDefaults be false. Let dateStyle be ? Get(options, "dateStyle"). Let timeStyle be ? Get(options, "timeStyle"). If dateStyle is not undefined or timeStyle is not undefined, let needDefaults be false. If required is "date" and timeStyle is not undefined, then Throw a TypeError exception. If required is "time" and dateStyle is not undefined, then Throw a TypeError exception. If needDefaults is true and defaults is either "date" or "all", then For each property name prop of Â« "year", "month", "day" Â», do Perform ? CreateDataPropertyOrThrow(options, prop, "numeric"). If needDefaults is true and defaults is either "time" or "all", then For each property name prop of Â« "hour", "minute", "second" Â», do Perform ? CreateDataPropertyOrThrow(options, prop, "numeric"). Return options. 11.5.2 DateTimeStyleFormat ( dateStyle, timeStyle, styles ) The DateTimeStyleFormat abstract operation accepts arguments dateStyle and timeStyle, which are each either undefined, "full", "long", "medium", or "short", at least one of which is not undefined, and styles, which is a record from %DateTimeFormat%.[[LocaleData]].[[<locale>]].[[styles]].[[<calendar>]] for some locale locale and calendar calendar. It returns the appropriate format record for date time formatting based on the parameters. If timeStyle is not undefined, then Assert: timeStyle is one of "full", "long", "medium", or "short". Let timeFormat be styles.[[TimeFormat]].[[<timeStyle>]]. If dateStyle is not undefined, then Assert: dateStyle is one of "full", "long", "medium", or "short". Let dateFormat be styles.[[DateFormat]].[[<dateStyle>]]. If dateStyle is not undefined and timeStyle is not undefined, then Let format be a new Record. Add to format all fields from dateFormat except [[pattern]] and [[rangePatterns]]. Add to format all fields from timeFormat except [[pattern]], [[rangePatterns]], [[pattern12]], and [[rangePatterns12]], if present. Let connector be styles.[[DateTimeFormat]].[[<dateStyle>]]. Let pattern be the string connector with the substring "{0}" replaced with timeFormat.[[pattern]] and the substring "{1}" replaced with dateFormat.[[pattern]]. Set format.[[pattern]] to pattern. If timeFormat has a [[pattern12]] field, then Let pattern12 be the string connector with the substring "{0}" replaced with timeFormat.[[pattern12]] and the substring "{1}" replaced with dateFormat.[[pattern]]. Set format.[[pattern12]] to pattern12. Let dateTimeRangeFormat be styles.[[DateTimeRangeFormat]].[[<dateStyle>]].[[<timeStyle>]]. Set format.[[rangePatterns]] to dateTimeRangeFormat.[[rangePatterns]]. If dateTimeRangeFormat has a [[rangePatterns12]] field, then Set format.[[rangePatterns12]] to dateTimeRangeFormat.[[rangePatterns12]]. Return format. If timeStyle is not undefined, then Return timeFormat. Assert: dateStyle is not undefined. Return dateFormat. 11.5.3 BasicFormatMatcher ( options, formats ) When the BasicFormatMatcher abstract operation is called with two arguments options and formats, the following steps are taken: Let removalPenalty be 120. Let additionPenalty be 20. Let longLessPenalty be 8. Let longMorePenalty be 6. Let shortLessPenalty be 6. Let shortMorePenalty be 3. Let offsetPenalty be 1. Let bestScore be -Infinity. Let bestFormat be undefined. Assert: Type(formats) is List. For each element format of formats, do Let score be 0. For each property name property shown in Table 6, do If options has a field [[<property>]], let optionsProp be options.[[<property>]]; else let optionsProp be undefined. If format has a field [[<property>]], let formatProp be format.[[<property>]]; else let formatProp be undefined. If optionsProp is undefined and formatProp is not undefined, decrease score by additionPenalty. Else if optionsProp is not undefined and formatProp is undefined, decrease score by removalPenalty. Else if property is "timeZoneName", then If optionsProp is "short" or "shortGeneric", then If formatProp is "shortOffset", decrease score by offsetPenalty. Else if formatProp is "longOffset", decrease score by (offsetPenalty + shortMorePenalty). Else if optionsProp is "short" and formatProp is "long", decrease score by shortMorePenalty. Else if optionsProp is "shortGeneric" and formatProp is "longGeneric", decrease score by shortMorePenalty. Else if optionsProp â‰  formatProp, decrease score by removalPenalty. Else if optionsProp is "shortOffset" and formatProp is "longOffset", decrease score by shortMorePenalty. Else if optionsProp is "long" or "longGeneric", then If formatProp is "longOffset", decrease score by offsetPenalty. Else if formatProp is "shortOffset", decrease score by (offsetPenalty + longLessPenalty). Else if optionsProp is "long" and formatProp is "short", decrease score by longLessPenalty. Else if optionsProp is "longGeneric" and formatProp is "shortGeneric", decrease score by longLessPenalty. Else if optionsProp â‰  formatProp, decrease score by removalPenalty. Else if optionsProp is "longOffset" and formatProp is "shortOffset", decrease score by longLessPenalty. Else if optionsProp â‰  formatProp, decrease score by removalPenalty. Else if optionsProp â‰  formatProp, then If property is "fractionalSecondDigits", then Let values be Â« 1ð?”½, 2ð?”½, 3ð?”½ Â». Else, Let values be Â« "2-digit", "numeric", "narrow", "short", "long" Â». Let optionsPropIndex be the index of optionsProp within values. Let formatPropIndex be the index of formatProp within values. Let delta be max(min(formatPropIndex - optionsPropIndex, 2), -2). If delta = 2, decrease score by longMorePenalty. Else if delta = 1, decrease score by shortMorePenalty. Else if delta = -1, decrease score by shortLessPenalty. Else if delta = -2, decrease score by longLessPenalty. If score > bestScore, then Let bestScore be score. Let bestFormat be format. Return bestFormat. 11.5.4 BestFitFormatMatcher ( options, formats ) When the BestFitFormatMatcher abstract operation is called with two arguments options and formats, it performs implementation dependent steps, which should return a set of component representations that a typical user of the selected locale would perceive as at least as good as the one returned by BasicFormatMatcher. 11.5.5 DateTime Format Functions A DateTime format function is an anonymous built-in function that has a [[DateTimeFormat]] internal slot. When a DateTime format function F is called with optional argument date, the following steps are taken: Let dtf be F.[[DateTimeFormat]]. Assert: Type(dtf) is Object and dtf has an [[InitializedDateTimeFormat]] internal slot. If date is not provided or is undefined, then Let x be ! Call(%Date.now%, undefined). Else, Let x be ? ToNumber(date). Return ? FormatDateTime(dtf, x). The "length" property of a DateTime format function is 1. 11.5.6 FormatDateTimePattern ( dateTimeFormat, patternParts, x, rangeFormatOptions ) The FormatDateTimePattern abstract operation is called with arguments dateTimeFormat (which must be an object initialized as a DateTimeFormat), patternParts (which is a list of Records as returned by PartitionPattern), x (which must be a Number value), and rangeFormatOptions (which is a range pattern Record as used in [[rangePattern]] or undefined), interprets x as a time value as specified in es2023, 20.4.1.1, and creates the corresponding parts according pattern and to the effective locale and the formatting options of dateTimeFormat and rangeFormatOptions. The following steps are taken: Let x be TimeClip(x). If x is NaN, throw a RangeError exception. Let locale be dateTimeFormat.[[Locale]]. Let nfOptions be ! OrdinaryObjectCreate(null). Perform ! CreateDataPropertyOrThrow(nfOptions, "useGrouping", false). Let nf be ? Construct(%NumberFormat%, Â« locale, nfOptions Â»). Let nf2Options be ! OrdinaryObjectCreate(null). Perform ! CreateDataPropertyOrThrow(nf2Options, "minimumIntegerDigits", 2). Perform ! CreateDataPropertyOrThrow(nf2Options, "useGrouping", false). Let nf2 be ? Construct(%NumberFormat%, Â« locale, nf2Options Â»). Let fractionalSecondDigits be dateTimeFormat.[[FractionalSecondDigits]]. If fractionalSecondDigits is not undefined, then Let nf3Options be ! OrdinaryObjectCreate(null). Perform ! CreateDataPropertyOrThrow(nf3Options, "minimumIntegerDigits", fractionalSecondDigits). Perform ! CreateDataPropertyOrThrow(nf3Options, "useGrouping", false). Let nf3 be ? Construct(%NumberFormat%, Â« locale, nf3Options Â»). Let tm be ToLocalTime(x, dateTimeFormat.[[Calendar]], dateTimeFormat.[[TimeZone]]). Let result be a new empty List. For each Record { [[Type]], [[Value]] } patternPart in patternParts, do Let p be patternPart.[[Type]]. If p is "literal", then Append a new Record { [[Type]]: "literal", [[Value]]: patternPart.[[Value]] } as the last element of the list result. Else if p is equal to "fractionalSecondDigits", then Let v be tm.[[Millisecond]]. Let v be floor(v Ã— 10( fractionalSecondDigits - 3 )). Let fv be FormatNumeric(nf3, v). Append a new Record { [[Type]]: "fractionalSecond", [[Value]]: fv } as the last element of result. Else if p is equal to "dayPeriod", then Let f be the value of dateTimeFormat's internal slot whose name is the Internal Slot column of the matching row. Let fv be a String value representing the day period of tm in the form given by f; the String value depends upon the implementation and the effective locale of dateTimeFormat. Append a new Record { [[Type]]: p, [[Value]]: fv } as the last element of the list result. Else if p is equal to "timeZoneName", then Let f be dateTimeFormat.[[TimeZoneName]]. Let v be dateTimeFormat.[[TimeZone]]. Let fv be a String value representing v in the form given by f; the String value depends upon the implementation and the effective locale of dateTimeFormat. The String value may also depend on the value of the [[InDST]] field of tm if f is "short", "long", "shortOffset", or "longOffset". If the implementation does not have a localized representation of f, then use the String value of v itself. Append a new Record { [[Type]]: p, [[Value]]: fv } as the last element of the list result. Else if p matches a Property column of the row in Table 6, then If rangeFormatOptions is not undefined, let f be the value of rangeFormatOptions's field whose name matches p. Else, let f be the value of dateTimeFormat's internal slot whose name is the Internal Slot column of the matching row. Let v be the value of tm's field whose name is the Internal Slot column of the matching row. If p is "year" and v â‰¤ 0, let v be 1 - v. If p is "month", increase v by 1. If p is "hour" and dateTimeFormat.[[HourCycle]] is "h11" or "h12", then Let v be v modulo 12. If v is 0 and dateTimeFormat.[[HourCycle]] is "h12", let v be 12. If p is "hour" and dateTimeFormat.[[HourCycle]] is "h24", then If v is 0, let v be 24. If f is "numeric", then Let fv be FormatNumeric(nf, v). Else if f is "2-digit", then Let fv be FormatNumeric(nf2, v). If the "length" property of fv is greater than 2, let fv be the substring of fv containing the last two characters. Else if f is "narrow", "short", or "long", then let fv be a String value representing v in the form given by f; the String value depends upon the implementation and the effective locale and calendar of dateTimeFormat. If p is "month" and rangeFormatOptions is undefined, then the String value may also depend on whether dateTimeFormat.[[Day]] is undefined. If p is "month" and rangeFormatOptions is not undefined, then the String value may also depend on whether rangeFormatOptions.[[day]] is undefined. If p is "era" and rangeFormatOptions is undefined, then the String value may also depend on whether dateTimeFormat.[[Era]] is undefined. If p is "era" and rangeFormatOptions is not undefined, then the String value may also depend on whether rangeFormatOptions.[[era]] is undefined. If the implementation does not have a localized representation of f, then use the String value of v itself. Append a new Record { [[Type]]: p, [[Value]]: fv } as the last element of the list result. Else if p is equal to "ampm", then Let v be tm.[[Hour]]. If v is greater than 11, then Let fv be an implementation and locale dependent String value representing "post meridiem". Else, Let fv be an implementation and locale dependent String value representing "ante meridiem". Append a new Record { [[Type]]: "dayPeriod", [[Value]]: fv } as the last element of the list result. Else if p is equal to "relatedYear", then Let v be tm.[[RelatedYear]]. Let fv be FormatNumeric(nf, v). Append a new Record { [[Type]]: "relatedYear", [[Value]]: fv } as the last element of the list result. Else if p is equal to "yearName", then Let v be tm.[[YearName]]. Let fv be an implementation and locale dependent String value representing v. Append a new Record { [[Type]]: "yearName", [[Value]]: fv } as the last element of the list result. Else, Let unknown be an implementation-, locale-, and numbering system-dependent String based on x and p. Append a new Record { [[Type]]: "unknown", [[Value]]: unknown } as the last element of result. Return result. Note 1 It is recommended that implementations use the locale and calendar dependent strings provided by the Common Locale Data Repository (available at https://cldr.unicode.org/), and use CLDR "abbreviated" strings for DateTimeFormat "short" strings, and CLDR "wide" strings for DateTimeFormat "long" strings. Note 2 It is recommended that implementations use the time zone information of the IANA Time Zone Database. 11.5.7 PartitionDateTimePattern ( dateTimeFormat, x ) The PartitionDateTimePattern abstract operation is called with arguments dateTimeFormat (which must be an object initialized as a DateTimeFormat) and x (which must be a Number value), interprets x as a time value as specified in es2023, 20.4.1.1, and creates the corresponding parts according to the effective locale and the formatting options of dateTimeFormat. The following steps are taken: Let patternParts be PartitionPattern(dateTimeFormat.[[Pattern]]). Let result be ? FormatDateTimePattern(dateTimeFormat, patternParts, x, undefined). Return result. 11.5.8 FormatDateTime ( dateTimeFormat, x ) The FormatDateTime abstract operation is called with arguments dateTimeFormat (which must be an object initialized as a DateTimeFormat) and x (which must be a Number value), and performs the following steps: Let parts be ? PartitionDateTimePattern(dateTimeFormat, x). Let result be the empty String. For each Record { [[Type]], [[Value]] } part in parts, do Set result to the string-concatenation of result and part.[[Value]]. Return result. 11.5.9 FormatDateTimeToParts ( dateTimeFormat, x ) The FormatDateTimeToParts abstract operation is called with arguments dateTimeFormat (which must be an object initialized as a DateTimeFormat) and x (which must be a Number value), and performs the following steps: Let parts be ? PartitionDateTimePattern(dateTimeFormat, x). Let result be ! ArrayCreate(0). Let n be 0. For each Record { [[Type]], [[Value]] } part in parts, do Let O be ! OrdinaryObjectCreate(%Object.prototype%). Perform ! CreateDataPropertyOrThrow(O, "type", part.[[Type]]). Perform ! CreateDataPropertyOrThrow(O, "value", part.[[Value]]). Perform ! CreateDataProperty(result, ! ToString(n), O). Increment n by 1. Return result. 11.5.10 PartitionDateTimeRangePattern ( dateTimeFormat, x, y ) The PartitionDateTimeRangePattern abstract operation is called with arguments dateTimeFormat (which must be an object initialized as a DateTimeFormat), x (which must be a Number value) and y (which must be a Number value), interprets x and y as time values as specified in es2023, 20.4.1.1, and creates the corresponding parts according to the effective locale and the formatting options of dateTimeFormat. The following steps are taken: Let x be TimeClip(x). If x is NaN, throw a RangeError exception. Let y be TimeClip(y). If y is NaN, throw a RangeError exception. If x is greater than y, throw a RangeError exception. Let tm1 be ToLocalTime(x, dateTimeFormat.[[Calendar]], dateTimeFormat.[[TimeZone]]). Let tm2 be ToLocalTime(y, dateTimeFormat.[[Calendar]], dateTimeFormat.[[TimeZone]]). Let rangePatterns be dateTimeFormat.[[RangePatterns]]. Let rangePattern be undefined. Let dateFieldsPracticallyEqual be true. Let patternContainsLargerDateField be false. While dateFieldsPracticallyEqual is true and patternContainsLargerDateField is false, repeat for each row of Table 4 in order, except the header row: Let fieldName be the name given in the Range Pattern Field column of the row. If rangePatterns has a field [[<fieldName>]], let rp be rangePatterns.[[<fieldName>]]; else let rp be undefined. If rangePattern is not undefined and rp is undefined, then Set patternContainsLargerDateField to true. Else, Let rangePattern be rp. If fieldName is equal to [[AmPm]], then Let v1 be tm1.[[Hour]]. Let v2 be tm2.[[Hour]]. If v1 is greater than 11 and v2 less or equal than 11, or v1 is less or equal than 11 and v2 is greater than 11, then Set dateFieldsPracticallyEqual to false. Else if fieldName is equal to [[DayPeriod]], then Let v1 be a String value representing the day period of tm1; the String value depends upon the implementation and the effective locale of dateTimeFormat. Let v2 be a String value representing the day period of tm2; the String value depends upon the implementation and the effective locale of dateTimeFormat. If v1 is not equal to v2, then Set dateFieldsPracticallyEqual to false. Else if fieldName is equal to [[FractionalSecondDigits]], then Let fractionalSecondDigits be dateTimeFormat.[[FractionalSecondDigits]]. If fractionalSecondDigits is undefined, then Set fractionalSecondDigits to 3. Let v1 be tm1.[[Millisecond]]. Let v2 be tm2.[[Millisecond]]. Let v1 be floor(v1 Ã— 10( fractionalSecondDigits - 3 )). Let v2 be floor(v2 Ã— 10( fractionalSecondDigits - 3 )). If v1 is not equal to v2, then Set dateFieldsPracticallyEqual to false. Else, Let v1 be tm1.[[<fieldName>]]. Let v2 be tm2.[[<fieldName>]]. If v1 is not equal to v2, then Set dateFieldsPracticallyEqual to false. If dateFieldsPracticallyEqual is true, then Let pattern be dateTimeFormat.[[Pattern]]. Let patternParts be PartitionPattern(pattern). Let result be ? FormatDateTimePattern(dateTimeFormat, patternParts, x, undefined). For each Record { [[Type]], [[Value]] } r in result, do Set r.[[Source]] to "shared". Return result. Let result be a new empty List. If rangePattern is undefined, then Let rangePattern be rangePatterns.[[Default]]. For each Record { [[Pattern]], [[Source]] } rangePatternPart in rangePattern.[[PatternParts]], do Let pattern be rangePatternPart.[[Pattern]]. Let source be rangePatternPart.[[Source]]. If source is "startRange" or "shared", then Let z be x. Else, Let z be y. Let patternParts be PartitionPattern(pattern). Let partResult be ? FormatDateTimePattern(dateTimeFormat, patternParts, z, rangePattern). For each Record { [[Type]], [[Value]] } r in partResult, do Set r.[[Source]] to source. Add all elements in partResult to result in order. Return result. 11.5.11 FormatDateTimeRange ( dateTimeFormat, x, y ) The FormatDateTimeRange abstract operation is called with arguments dateTimeFormat (which must be an object initialized as a DateTimeFormat), x (which must be a Number value) and y (which must be a Number value), and performs the following steps: Let parts be ? PartitionDateTimeRangePattern(dateTimeFormat, x, y). Let result be the empty String. For each Record { [[Type]], [[Value]], [[Source]] } part in parts, do Set result to the string-concatenation of result and part.[[Value]]. Return result. 11.5.12 FormatDateTimeRangeToParts ( dateTimeFormat, x, y ) The FormatDateTimeRangeToParts abstract operation is called with arguments dateTimeFormat (which must be an object initialized as a DateTimeFormat), x (which must be a Number value) and y (which must be a Number value), and performs the following steps: Let parts be ? PartitionDateTimeRangePattern(dateTimeFormat, x, y). Let result be ! ArrayCreate(0). Let n be 0. For each Record { [[Type]], [[Value]], [[Source]] } part in parts, do Let O be ! OrdinaryObjectCreate(%Object.prototype%). Perform ! CreateDataPropertyOrThrow(O, "type", part.[[Type]]). Perform ! CreateDataPropertyOrThrow(O, "value", part.[[Value]]). Perform ! CreateDataPropertyOrThrow(O, "source", part.[[Source]]). Perform ! CreateDataProperty(result, ! ToString(n), O). Increment n by 1. Return result. 11.5.13 ToLocalTime ( t, calendar, timeZone ) When the ToLocalTime abstract operation is called with arguments t, calendar, and timeZone, the following steps are taken: Assert: Type(t) is Number. If calendar is "gregory", then Let timeZoneOffset be the value calculated according to LocalTZA(t, true) where the local time zone is replaced with timezone timeZone. Let tz be the time value t + timeZoneOffset. Return a record with fields calculated from tz according to Table 7. Else, Return a record with the fields of Column 1 of Table 7 calculated from t for the given calendar and timeZone. The calculations should use best available information about the specified calendar and timeZone, including current and historical information about time zone offsets from UTC and daylight saving time rules. Table 7: Record returned by ToLocalTime Field Value Calculation for Gregorian Calendar [[Weekday]] WeekDay(tz) specified in es2023's Week Day [[Era]] Let year be YearFromTime(tz) specified in es2023's Year Number. If year is less than 0, return 'BC', else, return 'AD'. [[Year]] YearFromTime(tz) specified in es2023's Year Number [[RelatedYear]] undefined [[YearName]] undefined [[Month]] MonthFromTime(tz) specified in es2023's Month Number [[Day]] DateFromTime(tz) specified in es2023's Date Number [[Hour]] HourFromTime(tz) specified in es2023's Hours, Minutes, Second, and Milliseconds [[Minute]] MinFromTime(tz) specified in es2023's Hours, Minutes, Second, and Milliseconds [[Second]] SecFromTime(tz) specified in es2023's Hours, Minutes, Second, and Milliseconds [[Millisecond]] msFromTime(tz) specified in es2023's Hours, Minutes, Second, and Milliseconds [[InDST]] Calculate true or false using the best available information about the specified calendar and timeZone, including current and historical information about time zone offsets from UTC and daylight saving time rules. Note It is recommended that implementations use the time zone information of the IANA Time Zone Database. 11.5.14 UnwrapDateTimeFormat ( dtf ) The UnwrapDateTimeFormat abstract operation returns the DateTimeFormat instance of its input object, which is either the value itself or a value associated with it by %DateTimeFormat% according to the normative optional constructor mode of 4.3 Note 1. If Type(dtf) is not Object, throw a TypeError exception. If dtf does not have an [[InitializedDateTimeFormat]] internal slot and ? OrdinaryHasInstance(%DateTimeFormat%, dtf) is true, then Return ? Get(dtf, %Intl%.[[FallbackSymbol]]). Return dtf. 12 DisplayNames Objects 12.1 The Intl.DisplayNames Constructor The DisplayNames constructor is the %DisplayNames% intrinsic object and a standard built-in property of the Intl object. Behaviour common to all service constructor properties of the Intl object is specified in 9.1. 12.1.1 Intl.DisplayNames ( locales, options ) When the Intl.DisplayNames function is called with arguments locales and options, the following steps are taken: If NewTarget is undefined, throw a TypeError exception. Let displayNames be ? OrdinaryCreateFromConstructor(NewTarget, "%DisplayNames.prototype%", Â« [[InitializedDisplayNames]], [[Locale]], [[Style]], [[Type]], [[Fallback]], [[LanguageDisplay]], [[Fields]] Â»). Let requestedLocales be ? CanonicalizeLocaleList(locales). If options is undefined, throw a TypeError exception. Set options to ? GetOptionsObject(options). Let opt be a new Record. Let localeData be %DisplayNames%.[[LocaleData]]. Let matcher be ? GetOption(options, "localeMatcher", "string", Â« "lookup", "best fit" Â», "best fit"). Set opt.[[localeMatcher]] to matcher. Let r be ResolveLocale(%DisplayNames%.[[AvailableLocales]], requestedLocales, opt, %DisplayNames%.[[RelevantExtensionKeys]]). Let style be ? GetOption(options, "style", "string", Â« "narrow", "short", "long" Â», "long"). Set displayNames.[[Style]] to style. Let type be ? GetOption(options, "type", "string", Â« "language", "region", "script", "currency", "calendar", "dateTimeField" Â», undefined). If type is undefined, throw a TypeError exception. Set displayNames.[[Type]] to type. Let fallback be ? GetOption(options, "fallback", "string", Â« "code", "none" Â», "code"). Set displayNames.[[Fallback]] to fallback. Set displayNames.[[Locale]] to r.[[locale]]. Let dataLocale be r.[[dataLocale]]. Let dataLocaleData be localeData.[[<dataLocale>]]. Let types be dataLocaleData.[[types]]. Assert: types is a Record (see 12.2.3). Let languageDisplay be ? GetOption(options, "languageDisplay", "string", Â« "dialect", "standard" Â», "dialect"). Let typeFields be types.[[<type>]]. Assert: typeFields is a Record (see 12.2.3). If type is "language", then Set displayNames.[[LanguageDisplay]] to languageDisplay. Let typeFields be typeFields.[[<languageDisplay>]]. Assert: typeFields is a Record (see 12.2.3). Let styleFields be typeFields.[[<style>]]. Assert: styleFields is a Record (see 12.2.3). Set displayNames.[[Fields]] to styleFields. Return displayNames. 12.2 Properties of the Intl.DisplayNames Constructor The Intl.DisplayNames constructor has the following properties: 12.2.1 Intl.DisplayNames.prototype The value of Intl.DisplayNames.prototype is %DisplayNames.prototype%. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 12.2.2 Intl.DisplayNames.supportedLocalesOf ( locales [ , options ] ) When the supportedLocalesOf method is called with arguments locales and options, the following steps are taken: Let availableLocales be %DisplayNames%.[[AvailableLocales]]. Let requestedLocales be ? CanonicalizeLocaleList(locales). Return ? SupportedLocales(availableLocales, requestedLocales, options). 12.2.3 Internal slots The value of the [[AvailableLocales]] internal slot is implementation-defined within the constraints described in 9.1. The value of the [[RelevantExtensionKeys]] internal slot is Â« Â». The value of the [[LocaleData]] internal slot is implementation-defined within the constraints described in 9.1 and the following additional constraints: [[LocaleData]].[[<locale>]] must have a [[types]] field for all locale values locale. The value of this field must be a Record, which must have fields with the names of all display name types: "language", "region", "script", "currency", "calendar", and "dateTimeField". The value of the field "language" must be a Record which must have fields with the names of one of the valid language displays: "dialect" and "standard". The language display fields under display name type "language" should contain Records which must have fields with the names of one of the valid display name styles: "narrow", "short", and "long". The value of the fields "region", "script", "currency", "calendar", and "dateTimeField" must be Records, which must have fields with the names of all display name styles: "narrow", "short", and "long". The display name style fields under display name type "language" should contain Records with keys corresponding to language codes matching the unicode_language_id production. The value of these fields must be string values. The display name style fields under display name type "region" should contain Records with keys corresponding to region codes. The value of these fields must be string values. The display name style fields under display name type "script" should contain Records with keys corresponding to script codes. The value of these fields must be string values. The display name style fields under display name type "currency" should contain Records with keys corresponding to currency codes. The value of these fields must be string values. The display name style fields under display name type "calendar" should contain Records with keys corresponding to a String value with the type given in Unicode Technical Standard 35 for the calendar used for formatting. The value of these fields must be string values. The display name style fields under display name type "dateTimeField" should contain Records with keys corresponding to codes listed in Table 9. The value of these fields must be string values. Note It is recommended that implementations use the locale data provided by the Common Locale Data Repository (available at https://cldr.unicode.org/). 12.3 Properties of the Intl.DisplayNames Prototype Object The Intl.DisplayNames prototype object is itself an ordinary object. %DisplayNames.prototype% is not an Intl.DisplayNames instance and does not have an [[InitializedDisplayNames]] internal slot or any of the other internal slots of Intl.DisplayNames instance objects. 12.3.1 Intl.DisplayNames.prototype.constructor The initial value of Intl.DisplayNames.prototype.constructor is %DisplayNames%. 12.3.2 Intl.DisplayNames.prototype[ @@toStringTag ] The initial value of the @@toStringTag property is the String value "Intl.DisplayNames". This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }. 12.3.3 Intl.DisplayNames.prototype.of ( code ) When the Intl.DisplayNames.prototype.of is called with an argument code, the following steps are taken: Let displayNames be this value. Perform ? RequireInternalSlot(displayNames, [[InitializedDisplayNames]]). Let code be ? ToString(code). Let code be ? CanonicalCodeForDisplayNames(displayNames.[[Type]], code). Let fields be displayNames.[[Fields]]. If fields has a field [[<code>]], return fields.[[<code>]]. If displayNames.[[Fallback]] is "code", return code. Return undefined. 12.3.4 Intl.DisplayNames.prototype.resolvedOptions ( ) This function provides access to the locale and options computed during initialization of the object. Let displayNames be this value. Perform ? RequireInternalSlot(displayNames, [[InitializedDisplayNames]]). Let options be ! OrdinaryObjectCreate(%Object.prototype%). For each row of Table 8, except the header row, in table order, do Let p be the Property value of the current row. Let v be the value of displayNames's internal slot whose name is the Internal Slot value of the current row. Assert: v is not undefined. Perform ! CreateDataPropertyOrThrow(options, p, v). Return options. Table 8: Resolved Options of DisplayNames Instances Internal Slot Property [[Locale]] "locale" [[Style]] "style" [[Type]] "type" [[Fallback]] "fallback" [[LanguageDisplay]] "languageDisplay" 12.4 Properties of Intl.DisplayNames Instances Intl.DisplayNames instances are ordinary objects that inherit properties from %DisplayNames.prototype%. Intl.DisplayNames instances have an [[InitializedDisplayNames]] internal slot. Intl.DisplayNames instances also have several internal slots that are computed by the constructor: [[Locale]] is a String value with the language tag of the locale whose localization is used for formatting. [[Style]] is one of the String values "narrow", "short", or "long", identifying the display name style used. [[Type]] is one of the String values "language", "region", "script", "currency", "calendar", or "dateTimeField", identifying the type of the display names requested. [[Fallback]] is one of the String values "code" or "none", identifying the fallback return when the system does not have the requested display name. [[LanguageDisplay]] is one of the String values "dialect" or "standard", identifying the language display kind. It is only used when [[Type]] has the value "language". [[Fields]] is a Record (see 12.2.3) which must have fields with keys corresponding to codes according to [[Style]], [[Type]], and [[LanguageDisplay]]. 12.5 Abstract Operations for DisplayNames Objects 12.5.1 CanonicalCodeForDisplayNames ( type, code ) The CanonicalCodeForDisplayNames abstract operation takes arguments type (a String) and code (a String). It verifies that the code argument represents a well-formed code according to the type argument and returns the case-regularized form of the code. The algorithm refers to UTS 35's Unicode Language and Locale Identifiers grammar. The following steps are taken: If type is "language", then If code does not match the unicode_language_id production, throw a RangeError exception. If ! IsStructurallyValidLanguageTag(code) is false, throw a RangeError exception. Return ! CanonicalizeUnicodeLocaleId(code). If type is "region", then If code does not match the unicode_region_subtag production, throw a RangeError exception. Return the ASCII-uppercase of code. If type is "script", then If code does not match the unicode_script_subtag production, throw a RangeError exception. Assert: The length of code is 4, and every code unit of code represents an ASCII letter (0x0041 through 0x005A and 0x0061 through 0x007A, both inclusive). Let first be the ASCII-uppercase of the substring of code from 0 to 1. Let rest be the ASCII-lowercase of the substring of code from 1. Return the string-concatenation of first and rest. If type is "calendar", then If code does not match the Unicode Locale Identifier type nonterminal, throw a RangeError exception. If code uses any of the backwards compatibility syntax described in Unicode Technical Standard #35 LDML Â§ 3.3 BCP 47 Conformance, throw a RangeError exception. Return the ASCII-lowercase of code. If type is "dateTimeField", then If the result of IsValidDateTimeFieldCode(code) is false, throw a RangeError exception. Return code. Assert: type is "currency". If ! IsWellFormedCurrencyCode(code) is false, throw a RangeError exception. Return the ASCII-uppercase of code. 12.5.2 IsValidDateTimeFieldCode ( field ) The abstract operation IsValidDateTimeFieldCode takes argument field (a String). It verifies that the field argument represents a valid date time field code. It performs the following steps when called: If field is listed in the Code column of Table 9, return true. Return false. Table 9: Codes For Date Time Field of DisplayNames Code Description "era" The field indicating the era, e.g. AD or BC in the Gregorian or Julian calendar. "year" The field indicating the year (within an era). "quarter" The field indicating the quarter, e.g. Q2, 2nd quarter, etc. "month" The field indicating the month, e.g. Sep, September, etc. "weekOfYear" The field indicating the week number within a year. "weekday" The field indicating the day of week, e.g. Tue, Tuesday, etc. "day" The field indicating the day in month. "dayPeriod" The field indicating the day period, either am, pm, etc. or noon, evening, etc.. "hour" The field indicating the hour. "minute" The field indicating the minute. "second" The field indicating the second. "timeZoneName" The field indicating the time zone name, e.g. PDT, Pacific Daylight Time, etc. 13 ListFormat Objects 13.1 The Intl.ListFormat Constructor The ListFormat constructor is the %ListFormat% intrinsic object and a standard built-in property of the Intl object. Behaviour common to all service constructor properties of the Intl object is specified in 9.1. 13.1.1 Intl.ListFormat ( [ locales [ , options ] ] ) When the Intl.ListFormat function is called with optional arguments locales and options, the following steps are taken: If NewTarget is undefined, throw a TypeError exception. Let listFormat be ? OrdinaryCreateFromConstructor(NewTarget, "%ListFormat.prototype%", Â« [[InitializedListFormat]], [[Locale]], [[Type]], [[Style]], [[Templates]] Â»). Let requestedLocales be ? CanonicalizeLocaleList(locales). Set options to ? GetOptionsObject(options). Let opt be a new Record. Let matcher be ? GetOption(options, "localeMatcher", "string", Â« "lookup", "best fit" Â», "best fit"). Set opt.[[localeMatcher]] to matcher. Let localeData be %ListFormat%.[[LocaleData]]. Let r be ResolveLocale(%ListFormat%.[[AvailableLocales]], requestedLocales, opt, %ListFormat%.[[RelevantExtensionKeys]], localeData). Set listFormat.[[Locale]] to r.[[locale]]. Let type be ? GetOption(options, "type", "string", Â« "conjunction", "disjunction", "unit" Â», "conjunction"). Set listFormat.[[Type]] to type. Let style be ? GetOption(options, "style", "string", Â« "long", "short", "narrow" Â», "long"). Set listFormat.[[Style]] to style. Let dataLocale be r.[[dataLocale]]. Let dataLocaleData be localeData.[[<dataLocale>]]. Let dataLocaleTypes be dataLocaleData.[[<type>]]. Set listFormat.[[Templates]] to dataLocaleTypes.[[<style>]]. Return listFormat. 13.2 Properties of the Intl.ListFormat Constructor The Intl.ListFormat constructor has the following properties: 13.2.1 Intl.ListFormat.prototype The value of Intl.ListFormat.prototype is %ListFormat.prototype%. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 13.2.2 Intl.ListFormat.supportedLocalesOf ( locales [ , options ] ) When the supportedLocalesOf method is called with arguments locales and options, the following steps are taken: Let availableLocales be %ListFormat%.[[AvailableLocales]]. Let requestedLocales be ? CanonicalizeLocaleList(locales). Return ? SupportedLocales(availableLocales, requestedLocales, options). 13.2.3 Internal slots The value of the [[AvailableLocales]] internal slot is implementation-defined within the constraints described in 9.1. The value of the [[RelevantExtensionKeys]] internal slot is Â« Â». Note 1 Intl.ListFormat does not have any relevant extension keys. The value of the [[LocaleData]] internal slot is implementation-defined within the constraints described in 9.1 and the following additional constraints, for each locale value locale in %ListFormat%.[[AvailableLocales]]: [[LocaleData]].[[<locale>]] is a Record which has three fields [[conjunction]], [[disjunction]], and [[unit]]. Each of these is a Record which must have fields with the names of three formatting styles: [[long]], [[short]], and [[narrow]]. Each of those fields is considered a ListFormat template set, which must be a List of Records with fields named: [[Pair]], [[Start]], [[Middle]], and [[End]]. Each of those fields must be a template string as specified in LDML List Format Rules. Each template string must contain the substrings "{0}" and "{1}" exactly once. The substring "{0}" should occur before the substring "{1}". Note 2 It is recommended that implementations use the locale data provided by the Common Locale Data Repository (available at https://cldr.unicode.org/). In LDML's listPattern, conjunction corresponds to "standard", disjunction corresponds to "or", and unit corresponds to "unit". Note 3 Among the list types, conjunction stands for "and"-based lists (e.g., "A, B, and C"), disjunction stands for "or"-based lists (e.g., "A, B, or C"), and unit stands for lists of values with units (e.g., "5 pounds, 12 ounces"). 13.3 Properties of the Intl.ListFormat Prototype Object The Intl.ListFormat prototype object is itself an ordinary object. %ListFormat.prototype% is not an Intl.ListFormat instance and does not have an [[InitializedListFormat]] internal slot or any of the other internal slots of Intl.ListFormat instance objects. 13.3.1 Intl.ListFormat.prototype.constructor The initial value of Intl.ListFormat.prototype.constructor is %ListFormat%. 13.3.2 Intl.ListFormat.prototype [ @@toStringTag ] The initial value of the @@toStringTag property is the String value "Intl.ListFormat". This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }. 13.3.3 Intl.ListFormat.prototype.format ( list ) When the format method is called with an argument list, the following steps are taken: Let lf be the this value. Perform ? RequireInternalSlot(lf, [[InitializedListFormat]]). Let stringList be ? StringListFromIterable(list). Return ! FormatList(lf, stringList). 13.3.4 Intl.ListFormat.prototype.formatToParts ( list ) When the formatToParts method is called with an argument list, the following steps are taken: Let lf be the this value. Perform ? RequireInternalSlot(lf, [[InitializedListFormat]]). Let stringList be ? StringListFromIterable(list). Return ! FormatListToParts(lf, stringList). 13.3.5 Intl.ListFormat.prototype.resolvedOptions ( ) This function provides access to the locale and options computed during initialization of the object. Let lf be the this value. Perform ? RequireInternalSlot(lf, [[InitializedListFormat]]). Let options be ! OrdinaryObjectCreate(%Object.prototype%). For each row of Table 10, except the header row, in table order, do Let p be the Property value of the current row. Let v be the value of lf's internal slot whose name is the Internal Slot value of the current row. Assert: v is not undefined. Perform ! CreateDataPropertyOrThrow(options, p, v). Return options. Table 10: Resolved Options of ListFormat Instances Internal Slot Property [[Locale]] "locale" [[Type]] "type" [[Style]] "style" 13.4 Properties of Intl.ListFormat Instances Intl.ListFormat instances inherit properties from %ListFormat.prototype%. Intl.ListFormat instances have an [[InitializedListFormat]] internal slot. Intl.ListFormat instances also have several internal slots that are computed by the constructor: [[Locale]] is a String value with the language tag of the locale whose localization is used by the list format styles. [[Type]] is one of the String values "conjunction", "disjunction", or "unit", identifying the list of types used. [[Style]] is one of the String values "long", "short", or "narrow", identifying the list formatting style used. [[Templates]] is a ListFormat template set. 13.5 Abstract Operations for ListFormat Objects 13.5.1 DeconstructPattern ( pattern, placeables ) The DeconstructPattern abstract operation is called with arguments pattern (which must be a String) and placeables (which must be a Record), and deconstructs the pattern string into a list of parts. The placeables record is a record whose keys are placeables tokens used in the pattern string, and values are parts records which will be used in the result List to represent the token part. Example:  Input: DeconstructPattern("AA{xx}BB{yy}CC", { [[xx]]: {[[Type]]: "hour", [[Value]]: "15"}, [[yy]]: {[[Type]]: "minute", [[Value]]: "06"} }) Output (List of parts records): Â« {[[Type]]: "literal", [[Value]]: "AA"}, {[[Type]]: "hour", [[Value]]: "15"}, {[[Type]]: "literal", [[Value]]: "BB"}, {[[Type]]: "minute", [[Value]]: "06"}, {[[Type]]: "literal", [[Value]]: "CC"} Â» Let patternParts be ! PartitionPattern(pattern). Let result be a new empty List. For each Record { [[Type]], [[Value]] } patternPart of patternParts, do Let part be patternPart.[[Type]]. If part is "literal", then Append Record { [[Type]]: "literal", [[Value]]: patternPart.[[Value]] } to result. Else, Assert: placeables has a field [[<part>]]. Let subst be placeables.[[<part>]]. If Type(subst) is List, then For each element s of subst, do Append s to result. Else, Append subst to result. Return result. 13.5.2 CreatePartsFromList ( listFormat, list ) The CreatePartsFromList abstract operation is called with arguments listFormat (which must be an object initialized as a ListFormat) and list (which must be a List of String values), and creates the corresponding list of parts according to the effective locale and the formatting options of listFormat. Each part is a Record with two fields: [[Type]], which must be a string with values "element" or "literal", and [[Value]] which must be a string or a number. The following steps are taken: Let size be the number of elements of list. If size is 0, then Return a new empty List. If size is 2, then Let n be an index into listFormat.[[Templates]] based on listFormat.[[Locale]], list[0], and list[1]. Let pattern be listFormat.[[Templates]][n].[[Pair]]. Let first be a new Record { [[Type]]: "element", [[Value]]: list[0] }. Let second be a new Record { [[Type]]: "element", [[Value]]: list[1] }. Let placeables be a new Record { [[0]]: first, [[1]]: second }. Return ! DeconstructPattern(pattern, placeables). Let last be a new Record { [[Type]]: "element", [[Value]]: list[size - 1] }. Let parts be Â« last Â». Let i be size - 2. Repeat, while i â‰¥ 0, Let head be a new Record { [[Type]]: "element", [[Value]]: list[i] }. Let n be an implementation-defined index into listFormat.[[Templates]] based on listFormat.[[Locale]], head, and parts. If i is 0, then Let pattern be listFormat.[[Templates]][n].[[Start]]. Else if i is less than size - 2, then Let pattern be listFormat.[[Templates]][n].[[Middle]]. Else, Let pattern be listFormat.[[Templates]][n].[[End]]. Let placeables be a new Record { [[0]]: head, [[1]]: parts }. Set parts to ! DeconstructPattern(pattern, placeables). Decrement i by 1. Return parts. Note The index n to select across multiple templates permits the conjunction to be dependent on the context, as in Spanish, where either "y" or "e" may be selected, depending on the following word. 13.5.3 FormatList ( listFormat, list ) The FormatList abstract operation is called with arguments listFormat (which must be an object initialized as a ListFormat) and list (which must be a List of String values), and performs the following steps: Let parts be ! CreatePartsFromList(listFormat, list). Let result be an empty String. For each Record { [[Type]], [[Value]] } part in parts, do Set result to the string-concatenation of result and part.[[Value]]. Return result. 13.5.4 FormatListToParts ( listFormat, list ) The FormatListToParts abstract operation is called with arguments listFormat (which must be an object initialized as a ListFormat) and list (which must be a List of String values), and performs the following steps: Let parts be ! CreatePartsFromList(listFormat, list). Let result be ! ArrayCreate(0). Let n be 0. For each Record { [[Type]], [[Value]] } part in parts, do Let O be ! OrdinaryObjectCreate(%Object.prototype%). Perform ! CreateDataPropertyOrThrow(O, "type", part.[[Type]]). Perform ! CreateDataPropertyOrThrow(O, "value", part.[[Value]]). Perform ! CreateDataPropertyOrThrow(result, ! ToString(n), O). Increment n by 1. Return result. 13.5.5 StringListFromIterable ( iterable ) The abstract operation StringListFromIterable performs the following steps: If iterable is undefined, then Return a new empty List. Let iteratorRecord be ? GetIterator(iterable). Let list be a new empty List. Let next be true. Repeat, while next is not false, Set next to ? IteratorStep(iteratorRecord). If next is not false, then Let nextValue be ? IteratorValue(next). If Type(nextValue) is not String, then Let error be ThrowCompletion(a newly created TypeError object). Return ? IteratorClose(iteratorRecord, error). Append nextValue to the end of the List list. Return list. Note This algorithm raises exceptions when it encounters values that are not Strings, because there is no obvious locale-aware coercion for arbitrary values. 14 Locale Objects 14.1 The Intl.Locale Constructor The Locale constructor is the %Locale% intrinsic object and a standard built-in property of the Intl object. 14.1.1 Intl.Locale ( tag [ , options ] ) The following algorithm refers to the type nonterminal from UTS 35's Unicode Locale Identifier grammar. When the Intl.Locale function is called with an argument tag and an optional argument options, the following steps are taken: If NewTarget is undefined, throw a TypeError exception. Let relevantExtensionKeys be %Locale%.[[RelevantExtensionKeys]]. Let internalSlotsList be Â« [[InitializedLocale]], [[Locale]], [[Calendar]], [[Collation]], [[HourCycle]], [[NumberingSystem]] Â». If relevantExtensionKeys contains "kf", then Append [[CaseFirst]] as the last element of internalSlotsList. If relevantExtensionKeys contains "kn", then Append [[Numeric]] as the last element of internalSlotsList. Let locale be ? OrdinaryCreateFromConstructor(NewTarget, "%Locale.prototype%", internalSlotsList). If Type(tag) is not String or Object, throw a TypeError exception. If Type(tag) is Object and tag has an [[InitializedLocale]] internal slot, then Let tag be tag.[[Locale]]. Else, Let tag be ? ToString(tag). Set options to ? CoerceOptionsToObject(options). Set tag to ? ApplyOptionsToTag(tag, options). Let opt be a new Record. Let calendar be ? GetOption(options, "calendar", "string", undefined, undefined). If calendar is not undefined, then If calendar does not match the Unicode Locale Identifier type nonterminal, throw a RangeError exception. Set opt.[[ca]] to calendar. Let collation be ? GetOption(options, "collation", "string", undefined, undefined). If collation is not undefined, then If collation does not match the Unicode Locale Identifier type nonterminal, throw a RangeError exception. Set opt.[[co]] to collation. Let hc be ? GetOption(options, "hourCycle", "string", Â« "h11", "h12", "h23", "h24" Â», undefined). Set opt.[[hc]] to hc. Let kf be ? GetOption(options, "caseFirst", "string", Â« "upper", "lower", "false" Â», undefined). Set opt.[[kf]] to kf. Let kn be ? GetOption(options, "numeric", "boolean", undefined, undefined). If kn is not undefined, set kn to ! ToString(kn). Set opt.[[kn]] to kn. Let numberingSystem be ? GetOption(options, "numberingSystem", "string", undefined, undefined). If numberingSystem is not undefined, then If numberingSystem does not match the Unicode Locale Identifier type nonterminal, throw a RangeError exception. Set opt.[[nu]] to numberingSystem. Let r be ! ApplyUnicodeExtensionToTag(tag, opt, relevantExtensionKeys). Set locale.[[Locale]] to r.[[locale]]. Set locale.[[Calendar]] to r.[[ca]]. Set locale.[[Collation]] to r.[[co]]. Set locale.[[HourCycle]] to r.[[hc]]. If relevantExtensionKeys contains "kf", then Set locale.[[CaseFirst]] to r.[[kf]]. If relevantExtensionKeys contains "kn", then If ! SameValue(r.[[kn]], "true") is true or r.[[kn]] is the empty String, then Set locale.[[Numeric]] to true. Else, Set locale.[[Numeric]] to false. Set locale.[[NumberingSystem]] to r.[[nu]]. Return locale. 14.1.2 ApplyOptionsToTag ( tag, options ) The following algorithm refers to UTS 35's Unicode Language and Locale Identifiers grammar. Assert: Type(tag) is String. Assert: Type(options) is Object. If ! IsStructurallyValidLanguageTag(tag) is false, throw a RangeError exception. Let language be ? GetOption(options, "language", "string", undefined, undefined). If language is not undefined, then If language does not match the unicode_language_subtag production, throw a RangeError exception. Let script be ? GetOption(options, "script", "string", undefined, undefined). If script is not undefined, then If script does not match the unicode_script_subtag production, throw a RangeError exception. Let region be ? GetOption(options, "region", "string", undefined, undefined). If region is not undefined, then If region does not match the unicode_region_subtag production, throw a RangeError exception. Set tag to ! CanonicalizeUnicodeLocaleId(tag). Assert: tag matches the unicode_locale_id production. Let languageId be the substring of tag corresponding to the unicode_language_id production. If language is not undefined, then Set languageId to languageId with the substring corresponding to the unicode_language_subtag production replaced by the string language. If script is not undefined, then If languageId does not contain a unicode_script_subtag production, then Set languageId to the string-concatenation of the unicode_language_subtag production of languageId, "-", script, and the rest of languageId. Else, Set languageId to languageId with the substring corresponding to the unicode_script_subtag production replaced by the string script. If region is not undefined, then If languageId does not contain a unicode_region_subtag production, then Set languageId to the string-concatenation of the unicode_language_subtag production of languageId, the substring corresponding to "-"` and the `unicode_script_subtag` production if present, `"-", region, and the rest of languageId. Else, Set languageId to languageId with the substring corresponding to the unicode_region_subtag production replaced by the string region. Set tag to tag with the substring corresponding to the unicode_language_id production replaced by the string languageId. Return ! CanonicalizeUnicodeLocaleId(tag). 14.1.3 ApplyUnicodeExtensionToTag ( tag, options, relevantExtensionKeys ) The following algorithm refers to UTS 35's Unicode Language and Locale Identifiers grammar. Assert: Type(tag) is String. Assert: tag matches the unicode_locale_id production. If tag contains a substring that is a Unicode locale extension sequence, then Let extension be the String value consisting of the substring of the Unicode locale extension sequence within tag. Let components be ! UnicodeExtensionComponents(extension). Let attributes be components.[[Attributes]]. Let keywords be components.[[Keywords]]. Else, Let attributes be a new empty List. Let keywords be a new empty List. Let result be a new Record. For each element key of relevantExtensionKeys, do Let value be undefined. If keywords contains an element whose [[Key]] is the same as key, then Let entry be the element of keywords whose [[Key]] is the same as key. Let value be entry.[[Value]]. Else, Let entry be empty. Assert: options has a field [[<key>]]. Let optionsValue be options.[[<key>]]. If optionsValue is not undefined, then Assert: Type(optionsValue) is String. Let value be optionsValue. If entry is not empty, then Set entry.[[Value]] to value. Else, Append the Record { [[Key]]: key, [[Value]]: value } to keywords. Set result.[[<key>]] to value. Let locale be the String value that is tag with any Unicode locale extension sequences removed. Let newExtension be a Unicode BCP 47 U Extension based on attributes and keywords. If newExtension is not the empty String, then Let locale be ! InsertUnicodeExtensionAndCanonicalize(locale, newExtension). Set result.[[locale]] to locale. Return result. 14.2 Properties of the Intl.Locale Constructor The Intl.Locale constructor has the following properties: 14.2.1 Intl.Locale.prototype The value of Intl.Locale.prototype is %Locale.prototype%. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 14.2.2 Internal slots The value of the [[RelevantExtensionKeys]] internal slot is Â« "ca", "co", "hc", "kf", "kn", "nu" Â». If %Collator%.[[RelevantExtensionKeys]] does not contain "kf", then remove "kf" from %Locale%.[[RelevantExtensionKeys]]. If %Collator%.[[RelevantExtensionKeys]] does not contain "kn", then remove "kn" from %Locale%.[[RelevantExtensionKeys]]. 14.3 Properties of the Intl.Locale Prototype Object The Intl.Locale prototype object is itself an ordinary object. %Locale.prototype% is not an Intl.Locale instance and does not have an [[InitializedLocale]] internal slot or any of the other internal slots of Intl.Locale instance objects. 14.3.1 Intl.Locale.prototype.constructor The initial value of Intl.Locale.prototype.constructor is %Locale%. 14.3.2 Intl.Locale.prototype[ @@toStringTag ] The initial value of the @@toStringTag property is the String value "Intl.Locale". This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }. 14.3.3 Intl.Locale.prototype.maximize ( ) Let loc be the this value. Perform ? RequireInternalSlot(loc, [[InitializedLocale]]). Let maximal be the result of the Add Likely Subtags algorithm applied to loc.[[Locale]]. If an error is signaled, set maximal to loc.[[Locale]]. Return ! Construct(%Locale%, maximal). 14.3.4 Intl.Locale.prototype.minimize ( ) Let loc be the this value. Perform ? RequireInternalSlot(loc, [[InitializedLocale]]). Let minimal be the result of the Remove Likely Subtags algorithm applied to loc.[[Locale]]. If an error is signaled, set minimal to loc.[[Locale]]. Return ! Construct(%Locale%, minimal). 14.3.5 Intl.Locale.prototype.toString ( ) Let loc be the this value. Perform ? RequireInternalSlot(loc, [[InitializedLocale]]). Return loc.[[Locale]]. 14.3.6 get Intl.Locale.prototype.baseName Intl.Locale.prototype.baseName is an accessor property whose set accessor function is undefined. The following algorithm refers to UTS 35's Unicode Language and Locale Identifiers grammar. Its get accessor function performs the following steps: Let loc be the this value. Perform ? RequireInternalSlot(loc, [[InitializedLocale]]). Let locale be loc.[[Locale]]. Return the substring of locale corresponding to the unicode_language_id production. 14.3.7 get Intl.Locale.prototype.calendar Intl.Locale.prototype.calendar is an accessor property whose set accessor function is undefined. Its get accessor function performs the following steps: Let loc be the this value. Perform ? RequireInternalSlot(loc, [[InitializedLocale]]). Return loc.[[Calendar]]. 14.3.8 get Intl.Locale.prototype.caseFirst This property only exists if %Locale%.[[RelevantExtensionKeys]] contains "kf". Intl.Locale.prototype.caseFirst is an accessor property whose set accessor function is undefined. Its get accessor function performs the following steps: Let loc be the this value. Perform ? RequireInternalSlot(loc, [[InitializedLocale]]). Return loc.[[CaseFirst]]. 14.3.9 get Intl.Locale.prototype.collation Intl.Locale.prototype.collation is an accessor property whose set accessor function is undefined. Its get accessor function performs the following steps: Let loc be the this value. Perform ? RequireInternalSlot(loc, [[InitializedLocale]]). Return loc.[[Collation]]. 14.3.10 get Intl.Locale.prototype.hourCycle Intl.Locale.prototype.hourCycle is an accessor property whose set accessor function is undefined. Its get accessor function performs the following steps: Let loc be the this value. Perform ? RequireInternalSlot(loc, [[InitializedLocale]]). Return loc.[[HourCycle]]. 14.3.11 get Intl.Locale.prototype.numeric This property only exists if %Locale%.[[RelevantExtensionKeys]] contains "kn". Intl.Locale.prototype.numeric is an accessor property whose set accessor function is undefined. Its get accessor function performs the following steps: Let loc be the this value. Perform ? RequireInternalSlot(loc, [[InitializedLocale]]). Return loc.[[Numeric]]. 14.3.12 get Intl.Locale.prototype.numberingSystem Intl.Locale.prototype.numberingSystem is an accessor property whose set accessor function is undefined. Its get accessor function performs the following steps: Let loc be the this value. Perform ? RequireInternalSlot(loc, [[InitializedLocale]]). Return loc.[[NumberingSystem]]. 14.3.13 get Intl.Locale.prototype.language Intl.Locale.prototype.language is an accessor property whose set accessor function is undefined. The following algorithm refers to UTS 35's Unicode Language and Locale Identifiers grammar. Its get accessor function performs the following steps: Let loc be the this value. Perform ? RequireInternalSlot(loc, [[InitializedLocale]]). Let locale be loc.[[Locale]]. Assert: locale matches the unicode_locale_id production. Return the substring of locale corresponding to the unicode_language_subtag production of the unicode_language_id. 14.3.14 get Intl.Locale.prototype.script Intl.Locale.prototype.script is an accessor property whose set accessor function is undefined. The following algorithm refers to UTS 35's Unicode Language and Locale Identifiers grammar. Its get accessor function performs the following steps: Let loc be the this value. Perform ? RequireInternalSlot(loc, [[InitializedLocale]]). Let locale be loc.[[Locale]]. Assert: locale matches the unicode_locale_id production. If the unicode_language_id production of locale does not contain the ["-" unicode_script_subtag] sequence, return undefined. Return the substring of locale corresponding to the unicode_script_subtag production of the unicode_language_id. 14.3.15 get Intl.Locale.prototype.region Intl.Locale.prototype.region is an accessor property whose set accessor function is undefined. The following algorithm refers to UTS 35's Unicode Language and Locale Identifiers grammar. Its get accessor function performs the following steps: Let loc be the this value. Perform ? RequireInternalSlot(loc, [[InitializedLocale]]). Let locale be loc.[[Locale]]. Assert: locale matches the unicode_locale_id production. If the unicode_language_id production of locale does not contain the ["-" unicode_region_subtag] sequence, return undefined. Return the substring of locale corresponding to the unicode_region_subtag production of the unicode_language_id. 15 NumberFormat Objects 15.1 The Intl.NumberFormat Constructor The NumberFormat constructor is the %NumberFormat% intrinsic object and a standard built-in property of the Intl object. Behaviour common to all service constructor properties of the Intl object is specified in 9.1. 15.1.1 Intl.NumberFormat ( [ locales [ , options ] ] ) When the Intl.NumberFormat function is called with optional arguments locales and options, the following steps are taken: If NewTarget is undefined, let newTarget be the active function object, else let newTarget be NewTarget. Let numberFormat be ? OrdinaryCreateFromConstructor(newTarget, "%NumberFormat.prototype%", Â« [[InitializedNumberFormat]], [[Locale]], [[DataLocale]], [[NumberingSystem]], [[Style]], [[Unit]], [[UnitDisplay]], [[Currency]], [[CurrencyDisplay]], [[CurrencySign]], [[MinimumIntegerDigits]], [[MinimumFractionDigits]], [[MaximumFractionDigits]], [[MinimumSignificantDigits]], [[MaximumSignificantDigits]], [[RoundingType]], [[Notation]], [[CompactDisplay]], [[UseGrouping]], [[SignDisplay]], [[BoundFormat]] Â»). Perform ? InitializeNumberFormat(numberFormat, locales, options). If the implementation supports the normative optional constructor mode of 4.3 Note 1, then Let this be the this value. Return ? ChainNumberFormat(numberFormat, NewTarget, this). Return numberFormat. 15.1.1.1 ChainNumberFormat ( numberFormat, newTarget, this ) If newTarget is undefined and ? OrdinaryHasInstance(%NumberFormat%, this) is true, then Perform ? DefinePropertyOrThrow(this, %Intl%.[[FallbackSymbol]], PropertyDescriptor{ [[Value]]: numberFormat, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }). Return this. Return numberFormat. 15.1.2 InitializeNumberFormat ( numberFormat, locales, options ) The abstract operation InitializeNumberFormat accepts the arguments numberFormat (which must be an object), locales, and options. It initializes numberFormat as a NumberFormat object. The following steps are taken: The following algorithm refers to the type nonterminal from UTS 35's Unicode Locale Identifier grammar. Let requestedLocales be ? CanonicalizeLocaleList(locales). Set options to ? CoerceOptionsToObject(options). Let opt be a new Record. Let matcher be ? GetOption(options, "localeMatcher", "string", Â« "lookup", "best fit" Â», "best fit"). Set opt.[[localeMatcher]] to matcher. Let numberingSystem be ? GetOption(options, "numberingSystem", "string", undefined, undefined). If numberingSystem is not undefined, then If numberingSystem does not match the Unicode Locale Identifier type nonterminal, throw a RangeError exception. Set opt.[[nu]] to numberingSystem. Let localeData be %NumberFormat%.[[LocaleData]]. Let r be ResolveLocale(%NumberFormat%.[[AvailableLocales]], requestedLocales, opt, %NumberFormat%.[[RelevantExtensionKeys]], localeData). Set numberFormat.[[Locale]] to r.[[locale]]. Set numberFormat.[[DataLocale]] to r.[[dataLocale]]. Set numberFormat.[[NumberingSystem]] to r.[[nu]]. Perform ? SetNumberFormatUnitOptions(numberFormat, options). Let style be numberFormat.[[Style]]. If style is "currency", then Let currency be numberFormat.[[Currency]]. Let cDigits be CurrencyDigits(currency). Let mnfdDefault be cDigits. Let mxfdDefault be cDigits. Else, Let mnfdDefault be 0. If style is "percent", then Let mxfdDefault be 0. Else, Let mxfdDefault be 3. Let notation be ? GetOption(options, "notation", "string", Â« "standard", "scientific", "engineering", "compact" Â», "standard"). Set numberFormat.[[Notation]] to notation. Perform ? SetNumberFormatDigitOptions(numberFormat, options, mnfdDefault, mxfdDefault, notation). Let compactDisplay be ? GetOption(options, "compactDisplay", "string", Â« "short", "long" Â», "short"). If notation is "compact", then Set numberFormat.[[CompactDisplay]] to compactDisplay. Let useGrouping be ? GetOption(options, "useGrouping", "boolean", undefined, true). Set numberFormat.[[UseGrouping]] to useGrouping. Let signDisplay be ? GetOption(options, "signDisplay", "string", Â« "auto", "never", "always", "exceptZero" Â», "auto"). Set numberFormat.[[SignDisplay]] to signDisplay. Return numberFormat. 15.1.3 SetNumberFormatDigitOptions ( intlObj, options, mnfdDefault, mxfdDefault, notation ) The abstract operation SetNumberFormatDigitOptions takes arguments intlObj (an Object), options (an Object), mnfdDefault (a Number), mxfdDefault (a Number), and notation (a String). It populates the internal slots of intlObj that affect locale-independent number rounding (see 15.5.3). It performs the following steps when called: Let mnid be ? GetNumberOption(options, "minimumIntegerDigits,", 1, 21, 1). Let mnfd be ? Get(options, "minimumFractionDigits"). Let mxfd be ? Get(options, "maximumFractionDigits"). Let mnsd be ? Get(options, "minimumSignificantDigits"). Let mxsd be ? Get(options, "maximumSignificantDigits"). Set intlObj.[[MinimumIntegerDigits]] to mnid. If mnsd is not undefined or mxsd is not undefined, then Let hasSd be true. Else, Let hasSd be false. If mnfd is not undefined or mxfd is not undefined, then Let hasFd be true. Else, Let hasFd be false. Let needSd be hasSd. If hasSd is true, or hasFd is false and notation is "compact", then Let needFd be false. Else, Let needFd be true. If needSd is true, then Assert: hasSd is true. Set mnsd to ? DefaultNumberOption(mnsd, 1, 21, 1). Set mxsd to ? DefaultNumberOption(mxsd, mnsd, 21, 21). Set intlObj.[[MinimumSignificantDigits]] to mnsd. Set intlObj.[[MaximumSignificantDigits]] to mxsd. If needFd is true, then If hasFd is true, then Set mnfd to ? DefaultNumberOption(mnfd, 0, 20, undefined). Set mxfd to ? DefaultNumberOption(mxfd, 0, 20, undefined). If mnfd is undefined, set mnfd to min(mnfdDefault, mxfd). Else if mxfd is undefined, set mxfd to max(mxfdDefault, mnfd). Else if mnfd is greater than mxfd, throw a RangeError exception. Set intlObj.[[MinimumFractionDigits]] to mnfd. Set intlObj.[[MaximumFractionDigits]] to mxfd. Else, Set intlObj.[[MinimumFractionDigits]] to mnfdDefault. Set intlObj.[[MaximumFractionDigits]] to mxfdDefault. If needSd is false and needFd is false, then Set intlObj.[[RoundingType]] to compactRounding. Else if hasSd is true, then Set intlObj.[[RoundingType]] to significantDigits. Else, Set intlObj.[[RoundingType]] to fractionDigits. 15.1.4 SetNumberFormatUnitOptions ( intlObj, options ) The abstract operation SetNumberFormatUnitOptions resolves the user-specified options relating to units onto the intl object. Assert: Type(intlObj) is Object. Assert: Type(options) is Object. Let style be ? GetOption(options, "style", "string", Â« "decimal", "percent", "currency", "unit" Â», "decimal"). Set intlObj.[[Style]] to style. Let currency be ? GetOption(options, "currency", "string", undefined, undefined). If currency is undefined, then If style is "currency", throw a TypeError exception. Else, If ! IsWellFormedCurrencyCode(currency) is false, throw a RangeError exception. Let currencyDisplay be ? GetOption(options, "currencyDisplay", "string", Â« "code", "symbol", "narrowSymbol", "name" Â», "symbol"). Let currencySign be ? GetOption(options, "currencySign", "string", Â« "standard", "accounting" Â», "standard"). Let unit be ? GetOption(options, "unit", "string", undefined, undefined). If unit is undefined, then If style is "unit", throw a TypeError exception. Else, If ! IsWellFormedUnitIdentifier(unit) is false, throw a RangeError exception. Let unitDisplay be ? GetOption(options, "unitDisplay", "string", Â« "short", "narrow", "long" Â», "short"). If style is "currency", then Set intlObj.[[Currency]] to the ASCII-uppercase of currency. Set intlObj.[[CurrencyDisplay]] to currencyDisplay. Set intlObj.[[CurrencySign]] to currencySign. If style is "unit", then Set intlObj.[[Unit]] to unit. Set intlObj.[[UnitDisplay]] to unitDisplay. 15.2 Properties of the Intl.NumberFormat Constructor The Intl.NumberFormat constructor has the following properties: 15.2.1 Intl.NumberFormat.prototype The value of Intl.NumberFormat.prototype is %NumberFormat.prototype%. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 15.2.2 Intl.NumberFormat.supportedLocalesOf ( locales [ , options ] ) When the supportedLocalesOf method is called with arguments locales and options, the following steps are taken: Let availableLocales be %NumberFormat%.[[AvailableLocales]]. Let requestedLocales be ? CanonicalizeLocaleList(locales). Return ? SupportedLocales(availableLocales, requestedLocales, options). 15.2.3 Internal slots The value of the [[AvailableLocales]] internal slot is implementation-defined within the constraints described in 9.1. The value of the [[RelevantExtensionKeys]] internal slot is Â« "nu" Â». Note 1 Unicode Technical Standard 35 describes three locale extension keys that are relevant to number formatting: "cu" for currency, "cf" for currency format style, and "nu" for numbering system. Intl.NumberFormat, however, requires that the currency of a currency format is specified through the currency property in the options objects, and the currency format style of a currency format is specified through the currencySign property in the options objects. The value of the [[LocaleData]] internal slot is implementation-defined within the constraints described in 9.1 and the following additional constraints: The list that is the value of the "nu" field of any locale field of [[LocaleData]] must not include the values "native", "traditio", or "finance". [[LocaleData]].[[<locale>]] must have a [[patterns]] field for all locale values locale. The value of this field must be a Record, which must have fields with the names of the four number format styles: "decimal", "percent", "currency", and "unit". The two fields "currency" and "unit" noted above must be Records with at least one field, "fallback". The "currency" may have additional fields with keys corresponding to currency codes according to 6.3. Each field of "currency" must be a Record with fields corresponding to the possible currencyDisplay values: "code", "symbol", "narrowSymbol", and "name". Each of those fields must contain a Record with fields corresponding to the possible currencySign values: "standard" or "accounting". The "unit" field (of [[LocaleData]].[[<locale>]]) may have additional fields beyond the required field "fallback" with keys corresponding to core measurement unit identifiers corresponding to 6.5. Each field of "unit" must be a Record with fields corresponding to the possible unitDisplay values: "narrow", "short", and "long". All of the leaf fields so far described for the patterns tree ("decimal", "percent", great-grandchildren of "currency", and grandchildren of "unit") must be Records with the keys "positivePattern", "zeroPattern", and "negativePattern". The value of the aforementioned fields (the sign-dependent pattern fields) must be string values that must contain the substring "{number}". "positivePattern" must contain the substring "{plusSign}" but not "{minusSign}"; "negativePattern" must contain the substring "{minusSign}" but not "{plusSign}"; and "zeroPattern" must not contain either "{plusSign}" or "{minusSign}". Additionally, the values within the "percent" field must also contain the substring "{percentSign}"; the values within the "currency" field must also contain one or more of the following substrings: "{currencyCode}", "{currencyPrefix}", or "{currencySuffix}"; and the values within the "unit" field must also contain one or more of the following substrings: "{unitPrefix}" or "{unitSuffix}". The pattern strings must not contain any characters in the General Category "Number, decimal digit" as specified by the Unicode Standard. [[LocaleData]].[[<locale>]] must also have a [[notationSubPatterns]] field for all locale values locale. The value of this field must be a Record, which must have two fields: [[scientific]] and [[compact]]. The [[scientific]] field must be a string value containing the substrings "{number}", "{scientificSeparator}", and "{scientificExponent}". The [[compact]] field must be a Record with two fields: "short" and "long". Each of these fields must be a Record with integer keys corresponding to all discrete magnitudes the implementation supports for compact notation. Each of these fields must be a string value which may contain the substring "{number}". Strings descended from "short" must contain the substring "{compactSymbol}", and strings descended from "long" must contain the substring "{compactName}". Note 2 It is recommended that implementations use the locale data provided by the Common Locale Data Repository (available at https://cldr.unicode.org/). 15.3 Properties of the Intl.NumberFormat Prototype Object The Intl.NumberFormat prototype object is itself an ordinary object. %NumberFormat.prototype% is not an Intl.NumberFormat instance and does not have an [[InitializedNumberFormat]] internal slot or any of the other internal slots of Intl.NumberFormat instance objects. 15.3.1 Intl.NumberFormat.prototype.constructor The initial value of Intl.NumberFormat.prototype.constructor is %NumberFormat%. 15.3.2 Intl.NumberFormat.prototype [ @@toStringTag ] The initial value of the @@toStringTag property is the String value "Intl.NumberFormat". This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }. 15.3.3 get Intl.NumberFormat.prototype.format Intl.NumberFormat.prototype.format is an accessor property whose set accessor function is undefined. Its get accessor function performs the following steps: Let nf be the this value. If the implementation supports the normative optional constructor mode of 4.3 Note 1, then Set nf to ? UnwrapNumberFormat(nf). Perform ? RequireInternalSlot(nf, [[InitializedNumberFormat]]). If nf.[[BoundFormat]] is undefined, then Let F be a new built-in function object as defined in Number Format Functions (15.5.2). Set F.[[NumberFormat]] to nf. Set nf.[[BoundFormat]] to F. Return nf.[[BoundFormat]]. Note The returned function is bound to nf so that it can be passed directly to Array.prototype.map or other functions. This is considered a historical artefact, as part of a convention which is no longer followed for new features, but is preserved to maintain compatibility with existing programs. 15.3.4 Intl.NumberFormat.prototype.formatToParts ( value ) When the formatToParts method is called with an optional argument value, the following steps are taken: Let nf be the this value. Perform ? RequireInternalSlot(nf, [[InitializedNumberFormat]]). Let x be ? ToNumeric(value). Return ? FormatNumericToParts(nf, x). 15.3.5 Intl.NumberFormat.prototype.resolvedOptions ( ) This function provides access to the locale and options computed during initialization of the object. Let nf be the this value. If the implementation supports the normative optional constructor mode of 4.3 Note 1, then Set nf to ? UnwrapNumberFormat(nf). Perform ? RequireInternalSlot(nf, [[InitializedNumberFormat]]). Let options be ! OrdinaryObjectCreate(%Object.prototype%). For each row of Table 11, except the header row, in table order, do Let p be the Property value of the current row. Let v be the value of nf's internal slot whose name is the Internal Slot value of the current row. If v is not undefined, then Perform ! CreateDataPropertyOrThrow(options, p, v). Return options. Table 11: Resolved Options of NumberFormat Instances Internal Slot Property [[Locale]] "locale" [[NumberingSystem]] "numberingSystem" [[Style]] "style" [[Currency]] "currency" [[CurrencyDisplay]] "currencyDisplay" [[CurrencySign]] "currencySign" [[Unit]] "unit" [[UnitDisplay]] "unitDisplay" [[MinimumIntegerDigits]] "minimumIntegerDigits" [[MinimumFractionDigits]] "minimumFractionDigits" [[MaximumFractionDigits]] "maximumFractionDigits" [[MinimumSignificantDigits]] "minimumSignificantDigits" [[MaximumSignificantDigits]] "maximumSignificantDigits" [[UseGrouping]] "useGrouping" [[Notation]] "notation" [[CompactDisplay]] "compactDisplay" [[SignDisplay]] "signDisplay" 15.4 Properties of Intl.NumberFormat Instances Intl.NumberFormat instances are ordinary objects that inherit properties from %NumberFormat.prototype%. Intl.NumberFormat instances have an [[InitializedNumberFormat]] internal slot. Intl.NumberFormat instances also have several internal slots that are computed by the constructor: [[Locale]] is a String value with the language tag of the locale whose localization is used for formatting. [[DataLocale]] is a String value with the language tag of the nearest locale for which the implementation has data to perform the formatting operation. It will be a parent locale of [[Locale]]. [[NumberingSystem]] is a String value with the "type" given in Unicode Technical Standard 35 for the numbering system used for formatting. [[Style]] is one of the String values "decimal", "currency", "percent", or "unit", identifying the type of quantity being measured. [[Currency]] is a String value with the currency code identifying the currency to be used if formatting with the "currency" unit type. It is only used when [[Style]] has the value "currency". [[CurrencyDisplay]] is one of the String values "code", "symbol", "narrowSymbol", or "name", specifying whether to display the currency as an ISO 4217 alphabetic currency code, a localized currency symbol, or a localized currency name if formatting with the "currency" style. It is only used when [[Style]] has the value "currency". [[CurrencySign]] is one of the String values "standard" or "accounting", specifying whether to render negative numbers in accounting format, often signified by parenthesis. It is only used when [[Style]] has the value "currency" and when [[SignDisplay]] is not "never". [[Unit]] is a core unit identifier, as defined by Unicode Technical Standard #35, Part 2, Section 6. It is only used when [[Style]] has the value "unit". [[UnitDisplay]] is one of the String values "short", "narrow", or "long", specifying whether to display the unit as a symbol, narrow symbol, or localized long name if formatting with the "unit" style. It is only used when [[Style]] has the value "unit". [[MinimumIntegerDigits]] is a non-negative integer Number value indicating the minimum integer digits to be used. Numbers will be padded with leading zeroes if necessary. [[MinimumFractionDigits]] and [[MaximumFractionDigits]] are non-negative integer Number values indicating the minimum and maximum fraction digits to be used. Numbers will be rounded or padded with trailing zeroes if necessary. These properties are only used when [[RoundingType]] is fractionDigits. [[MinimumSignificantDigits]] and [[MaximumSignificantDigits]] are positive integer Number values indicating the minimum and maximum fraction digits to be shown. If present, the formatter uses however many fraction digits are required to display the specified number of significant digits. These properties are only used when [[RoundingType]] is significantDigits. [[UseGrouping]] is a Boolean value indicating whether a grouping separator should be used. [[RoundingType]] is one of the values fractionDigits, significantDigits, or compactRounding, indicating which rounding strategy to use. If fractionDigits, the number is rounded according to [[MinimumFractionDigits]] and [[MaximumFractionDigits]], as described above. If significantDigits, the number is rounded according to [[MinimumSignificantDigits]] and [[MaximumSignificantDigits]] as described above. If compactRounding, the number is rounded to 1 maximum fraction digit if there is 1 digit before the decimal separator, and otherwise round to 0 fraction digits. [[Notation]] is one of the String values "standard", "scientific", "engineering", or "compact", specifying whether the number should be displayed without scaling, scaled to the units place with the power of ten in scientific notation, scaled to the nearest thousand with the power of ten in scientific notation, or scaled to the nearest locale-dependent compact decimal notation power of ten with the corresponding compact decimal notation affix. [[CompactDisplay]] is one of the String values "short" or "long", specifying whether to display compact notation affixes in short form ("5K") or long form ("5 thousand") if formatting with the "compact" notation. It is only used when [[Notation]] has the value "compact". [[SignDisplay]] is one of the String values "auto", "always", "never", or "exceptZero", specifying whether to show the sign on negative numbers only, positive and negative numbers including zero, neither positive nor negative numbers, or positive and negative numbers but not zero. In scientific notation, this slot affects the sign display of the mantissa but not the exponent. Finally, Intl.NumberFormat instances have a [[BoundFormat]] internal slot that caches the function returned by the format accessor (15.3.3). 15.5 Abstract Operations for NumberFormat Objects 15.5.1 CurrencyDigits ( currency ) When the CurrencyDigits abstract operation is called with an argument currency (which must be an uppercase String value), the following steps are taken: If the ISO 4217 currency and funds code list contains currency as an alphabetic code, return the minor unit value corresponding to the currency from the list; otherwise, return 2. 15.5.2 Number Format Functions A Number format function is an anonymous built-in function that has a [[NumberFormat]] internal slot. When a Number format function F is called with optional argument value, the following steps are taken: Let nf be F.[[NumberFormat]]. Assert: Type(nf) is Object and nf has an [[InitializedNumberFormat]] internal slot. If value is not provided, let value be undefined. Let x be ? ToNumeric(value). Return ? FormatNumeric(nf, x). The "length" property of a Number format function is 1. 15.5.3 FormatNumericToString ( intlObject, x ) The FormatNumericToString abstract operation is called with arguments intlObject (which must be an object with [[RoundingType]], [[MinimumSignificantDigits]], [[MaximumSignificantDigits]], [[MinimumIntegerDigits]], [[MinimumFractionDigits]], and [[MaximumFractionDigits]] internal slots), and x (which must be a Number or BigInt value), and returns a Record containing two values: x as a String value with digits formatted according to the five formatting parameters in the field [[FormattedString]], and the final floating decimal value of x after rounding has been performed in the field [[RoundedNumber]]. If â„?(x) < 0 or x is -0ð?”½, let isNegative be true; else let isNegative be false. If isNegative, then Let x be -x. If intlObject.[[RoundingType]] is significantDigits, then Let result be ToRawPrecision(x, intlObject.[[MinimumSignificantDigits]], intlObject.[[MaximumSignificantDigits]]). Else if intlObject.[[RoundingType]] is fractionDigits, then Let result be ToRawFixed(x, intlObject.[[MinimumFractionDigits]], intlObject.[[MaximumFractionDigits]]). Else, Assert: intlObject.[[RoundingType]] is compactRounding. Let result be ToRawPrecision(x, 1, 2). If result.[[IntegerDigitsCount]] > 1, then Let result be ToRawFixed(x, 0, 0). Let x be result.[[RoundedNumber]]. Let string be result.[[FormattedString]]. Let int be result.[[IntegerDigitsCount]]. Let minInteger be intlObject.[[MinimumIntegerDigits]]. If int < minInteger, then Let forwardZeros be the String consisting of minIntegerâ€“int occurrences of the character "0". Set string to the string-concatenation of forwardZeros and string. If isNegative, then Let x be -x. Return the Record { [[RoundedNumber]]: x, [[FormattedString]]: string }. 15.5.4 PartitionNumberPattern ( numberFormat, x ) The abstract operation PartitionNumberPattern takes arguments numberFormat (an object initialized as a NumberFormat) and x (a Number or a BigInt). It creates the parts representing the mathematical value of x according to the effective locale and the formatting options of numberFormat. It performs the following steps when called: Let exponent be 0. If x is NaN, then Let n be an implementation- and locale-dependent (ILD) String value indicating the NaN value. Else if x is +âˆžð?”½, then Let n be an ILD String value indicating positive infinity. Else if x is -âˆžð?”½, then Let n be an ILD String value indicating negative infinity. Else, Set x to â„?(x). If numberFormat.[[Style]] is "percent", set x to 100 Ã— x. Let exponent be ComputeExponent(numberFormat, x). Set x to x Ã— 10-exponent. Let formatNumberResult be FormatNumericToString(numberFormat, x). Let n be formatNumberResult.[[FormattedString]]. Set x to formatNumberResult.[[RoundedNumber]]. Let pattern be GetNumberFormatPattern(numberFormat, x). Let result be a new empty List. Let patternParts be PartitionPattern(pattern). For each Record { [[Type]], [[Value]] } patternPart of patternParts, do Let p be patternPart.[[Type]]. If p is "literal", then Append a new Record { [[Type]]: "literal", [[Value]]: patternPart.[[Value]] } as the last element of result. Else if p is equal to "number", then Let notationSubParts be PartitionNotationSubPattern(numberFormat, x, n, exponent). Append all elements of notationSubParts to result. Else if p is equal to "plusSign", then Let plusSignSymbol be the ILND String representing the plus sign. Append a new Record { [[Type]]: "plusSign", [[Value]]: plusSignSymbol } as the last element of result. Else if p is equal to "minusSign", then Let minusSignSymbol be the ILND String representing the minus sign. Append a new Record { [[Type]]: "minusSign", [[Value]]: minusSignSymbol } as the last element of result. Else if p is equal to "percentSign" and numberFormat.[[Style]] is "percent", then Let percentSignSymbol be the ILND String representing the percent sign. Append a new Record { [[Type]]: "percentSign", [[Value]]: percentSignSymbol } as the last element of result. Else if p is equal to "unitPrefix" and numberFormat.[[Style]] is "unit", then Let unit be numberFormat.[[Unit]]. Let unitDisplay be numberFormat.[[UnitDisplay]]. Let mu be an ILD String value representing unit before x in unitDisplay form, which may depend on x in languages having different plural forms. Append a new Record { [[Type]]: "unit", [[Value]]: mu } as the last element of result. Else if p is equal to "unitSuffix" and numberFormat.[[Style]] is "unit", then Let unit be numberFormat.[[Unit]]. Let unitDisplay be numberFormat.[[UnitDisplay]]. Let mu be an ILD String value representing unit after x in unitDisplay form, which may depend on x in languages having different plural forms. Append a new Record { [[Type]]: "unit", [[Value]]: mu } as the last element of result. Else if p is equal to "currencyCode" and numberFormat.[[Style]] is "currency", then Let currency be numberFormat.[[Currency]]. Let cd be currency. Append a new Record { [[Type]]: "currency", [[Value]]: cd } as the last element of result. Else if p is equal to "currencyPrefix" and numberFormat.[[Style]] is "currency", then Let currency be numberFormat.[[Currency]]. Let currencyDisplay be numberFormat.[[CurrencyDisplay]]. Let cd be an ILD String value representing currency before x in currencyDisplay form, which may depend on x in languages having different plural forms. Append a new Record { [[Type]]: "currency", [[Value]]: cd } as the last element of result. Else if p is equal to "currencySuffix" and numberFormat.[[Style]] is "currency", then Let currency be numberFormat.[[Currency]]. Let currencyDisplay be numberFormat.[[CurrencyDisplay]]. Let cd be an ILD String value representing currency after x in currencyDisplay form, which may depend on x in languages having different plural forms. If the implementation does not have such a representation of currency, use currency itself. Append a new Record { [[Type]]: "currency", [[Value]]: cd } as the last element of result. Else, Let unknown be an ILND String based on x and p. Append a new Record { [[Type]]: "unknown", [[Value]]: unknown } as the last element of result. Return result. 15.5.5 PartitionNotationSubPattern ( numberFormat, x, n, exponent ) The PartitionNotationSubPattern abstract operation is called with arguments numberFormat (which must be an object initialized as a NumberFormat), x (which is a numeric value after rounding is applied), n (which is an intermediate formatted string), and exponent (an integer), and creates the corresponding parts for the number and notation according to the effective locale and the formatting options of numberFormat. The following steps are taken: Let result be a new empty List. If x is NaN, then Append a new Record { [[Type]]: "nan", [[Value]]: n } as the last element of result. Else if x is a non-finite Number, then Append a new Record { [[Type]]: "infinity", [[Value]]: n } as the last element of result. Else, Let notationSubPattern be GetNotationSubPattern(numberFormat, exponent). Let patternParts be PartitionPattern(notationSubPattern). For each Record { [[Type]], [[Value]] } patternPart of patternParts, do Let p be patternPart.[[Type]]. If p is "literal", then Append a new Record { [[Type]]: "literal", [[Value]]: patternPart.[[Value]] } as the last element of result. Else if p is equal to "number", then If the numberFormat.[[NumberingSystem]] matches one of the values in the "Numbering System" column of Table 12 below, then Let digits be a List whose 10 String valued elements are the UTF-16 string representations of the 10 digits specified in the "Digits" column of the matching row in Table 12. Replace each digit in n with the value of digits[digit]. Else use an implementation dependent algorithm to map n to the appropriate representation of n in the given numbering system. Let decimalSepIndex be ! StringIndexOf(n, ".", 0). If decimalSepIndex > 0, then Let integer be the substring of n from position 0, inclusive, to position decimalSepIndex, exclusive. Let fraction be the substring of n from position decimalSepIndex, exclusive, to the end of n. Else, Let integer be n. Let fraction be undefined. If the numberFormat.[[UseGrouping]] is true, then Let groupSepSymbol be the implementation-, locale-, and numbering system-dependent (ILND) String representing the grouping separator. Let groups be a List whose elements are, in left to right order, the substrings defined by ILND set of locations within the integer. Assert: The number of elements in groups List is greater than 0. Repeat, while groups List is not empty, Remove the first element from groups and let integerGroup be the value of that element. Append a new Record { [[Type]]: "integer", [[Value]]: integerGroup } as the last element of result. If groups List is not empty, then Append a new Record { [[Type]]: "group", [[Value]]: groupSepSymbol } as the last element of result. Else, Append a new Record { [[Type]]: "integer", [[Value]]: integer } as the last element of result. If fraction is not undefined, then Let decimalSepSymbol be the ILND String representing the decimal separator. Append a new Record { [[Type]]: "decimal", [[Value]]: decimalSepSymbol } as the last element of result. Append a new Record { [[Type]]: "fraction", [[Value]]: fraction } as the last element of result. Else if p is equal to "compactSymbol", then Let compactSymbol be an ILD string representing exponent in short form, which may depend on x in languages having different plural forms. The implementation must be able to provide this string, or else the pattern would not have a "{compactSymbol}" placeholder. Append a new Record { [[Type]]: "compact", [[Value]]: compactSymbol } as the last element of result. Else if p is equal to "compactName", then Let compactName be an ILD string representing exponent in long form, which may depend on x in languages having different plural forms. The implementation must be able to provide this string, or else the pattern would not have a "{compactName}" placeholder. Append a new Record { [[Type]]: "compact", [[Value]]: compactName } as the last element of result. Else if p is equal to "scientificSeparator", then Let scientificSeparator be the ILND String representing the exponent separator. Append a new Record { [[Type]]: "exponentSeparator", [[Value]]: scientificSeparator } as the last element of result. Else if p is equal to "scientificExponent", then If exponent < 0, then Let minusSignSymbol be the ILND String representing the minus sign. Append a new Record { [[Type]]: "exponentMinusSign", [[Value]]: minusSignSymbol } as the last element of result. Let exponent be -exponent. Let exponentResult be ToRawFixed(exponent, 1, 0, 0). Append a new Record { [[Type]]: "exponentInteger", [[Value]]: exponentResult.[[FormattedString]] } as the last element of result. Else, Let unknown be an ILND String based on x and p. Append a new Record { [[Type]]: "unknown", [[Value]]: unknown } as the last element of result. Return result. Table 12: Numbering systems with simple digit mappings Numbering System Digits adlm U+1E950 to U+1E959 ahom U+11730 to U+11739 arab U+0660 to U+0669 arabext U+06F0 to U+06F9 bali U+1B50 to U+1B59 beng U+09E6 to U+09EF bhks U+11C50 to U+11C59 brah U+11066 to U+1106F cakm U+11136 to U+1113F cham U+AA50 to U+AA59 deva U+0966 to U+096F diak U+11950 to U+11959 fullwide U+FF10 to U+FF19 gong U+11DA0 to U+11DA9 gonm U+11D50 to U+11D59 gujr U+0AE6 to U+0AEF guru U+0A66 to U+0A6F hanidec U+3007, U+4E00, U+4E8C, U+4E09, U+56DB, U+4E94, U+516D, U+4E03, U+516B, U+4E5D hmng U+16B50 to U+16B59 hmnp U+1E140 to U+1E149 java U+A9D0 to U+A9D9 kali U+A900 to U+A909 khmr U+17E0 to U+17E9 knda U+0CE6 to U+0CEF lana U+1A80 to U+1A89 lanatham U+1A90 to U+1A99 laoo U+0ED0 to U+0ED9 latn U+0030 to U+0039 lepc U+1C40 to U+1C49 limb U+1946 to U+194F mathbold U+1D7CE to U+1D7D7 mathdbl U+1D7D8 to U+1D7E1 mathmono U+1D7F6 to U+1D7FF mathsanb U+1D7EC to U+1D7F5 mathsans U+1D7E2 to U+1D7EB mlym U+0D66 to U+0D6F modi U+11650 to U+11659 mong U+1810 to U+1819 mroo U+16A60 to U+16A69 mtei U+ABF0 to U+ABF9 mymr U+1040 to U+1049 mymrshan U+1090 to U+1099 mymrtlng U+A9F0 to U+A9F9 newa U+11450 to U+11459 nkoo U+07C0 to U+07C9 olck U+1C50 to U+1C59 orya U+0B66 to U+0B6F osma U+104A0 to U+104A9 rohg U+10D30 to U+10D39 saur U+A8D0 to U+A8D9 segment U+1FBF0 to U+1FBF9 shrd U+111D0 to U+111D9 sind U+112F0 to U+112F9 sinh U+0DE6 to U+0DEF sora U+110F0 to U+110F9 sund U+1BB0 to U+1BB9 takr U+116C0 to U+116C9 talu U+19D0 to U+19D9 tamldec U+0BE6 to U+0BEF telu U+0C66 to U+0C6F thai U+0E50 to U+0E59 tibt U+0F20 to U+0F29 tirh U+114D0 to U+114D9 tnsa U+16AC0 to U+16AC9 vaii U+A620 to U+A629 wara U+118E0 to U+118E9 wcho U+1E2F0 to U+1E2F9 Note 1 The computations rely on String values and locations within numeric strings that are dependent upon the implementation and the effective locale of numberFormat ("ILD") or upon the implementation, the effective locale, and the numbering system of numberFormat ("ILND"). The ILD and ILND Strings mentioned, other than those for currency names, must not contain any characters in the General Category "Number, decimal digit" as specified by the Unicode Standard. Note 2 It is recommended that implementations use the locale provided by the Common Locale Data Repository (available at https://cldr.unicode.org/). 15.5.6 FormatNumeric ( numberFormat, x ) The FormatNumeric abstract operation is called with arguments numberFormat (which must be an object initialized as a NumberFormat) and x (which must be a Number or BigInt value), and performs the following steps: Let parts be ? PartitionNumberPattern(numberFormat, x). Let result be the empty String. For each Record { [[Type]], [[Value]] } part in parts, do Set result to the string-concatenation of result and part.[[Value]]. Return result. 15.5.7 FormatNumericToParts ( numberFormat, x ) The FormatNumericToParts abstract operation is called with arguments numberFormat (which must be an object initialized as a NumberFormat) and x (which must be a Number or BigInt value), and performs the following steps: Let parts be ? PartitionNumberPattern(numberFormat, x). Let result be ! ArrayCreate(0). Let n be 0. For each Record { [[Type]], [[Value]] } part in parts, do Let O be ! OrdinaryObjectCreate(%Object.prototype%). Perform ! CreateDataPropertyOrThrow(O, "type", part.[[Type]]). Perform ! CreateDataPropertyOrThrow(O, "value", part.[[Value]]). Perform ! CreateDataPropertyOrThrow(result, ! ToString(n), O). Increment n by 1. Return result. 15.5.8 ToRawPrecision ( x, minPrecision, maxPrecision ) When the ToRawPrecision abstract operation is called with arguments x (which must be a finite non-negative Number or BigInt), minPrecision, and maxPrecision (both must be integers between 1 and 21), the following steps are taken: Set x to â„?(x). Let p be maxPrecision. If x = 0, then Let m be the String consisting of p occurrences of the character "0". Let e be 0. Let xFinal be 0. Else, Let e and n be integers such that 10p - 1 â‰¤ n < 10p and for which n Ã— 10e - p + 1 - x is as close to zero as possible. If there are two such sets of e and n, pick the e and n for which n Ã— 10e - p + 1 is larger. Let m be the String consisting of the digits of the decimal representation of n (in order, with no leading zeroes). Let xFinal be n Ã— 10eâ€“p+1. If e â‰¥ pâ€“1, then Let m be the string-concatenation of m and eâ€“p+1 occurrences of the character "0". Let int be e+1. Else if e â‰¥ 0, then Let m be the string-concatenation of the first e+1 characters of m, the character ".", and the remaining pâ€“(e+1) characters of m. Let int be e+1. Else, Assert: e < 0. Let m be the string-concatenation of "0.", â€“(e+1) occurrences of the character "0", and m. Let int be 1. If m contains the character ".", and maxPrecision > minPrecision, then Let cut be maxPrecision â€“ minPrecision. Repeat, while cut > 0 and the last character of m is "0", Remove the last character from m. Decrease cut by 1. If the last character of m is ".", then Remove the last character from m. Return the Record { [[FormattedString]]: m, [[RoundedNumber]]: xFinal, [[IntegerDigitsCount]]: int }. 15.5.9 ToRawFixed ( x, minInteger, minFraction, maxFraction ) When the ToRawFixed abstract operation is called with arguments x (which must be a finite non-negative Number or BigInt), minInteger (which must be an integer between 1 and 21), minFraction, and maxFraction (which must be integers between 0 and 20), the following steps are taken: Set x to â„?(x). Let f be maxFraction. Let n be an integer for which the exact mathematical value of n / 10f â€“ x is as close to zero as possible. If there are two such n, pick the larger n. Let xFinal be n / 10f. If n = 0, let m be "0". Otherwise, let m be the String consisting of the digits of the decimal representation of n (in order, with no leading zeroes). If f â‰  0, then Let k be the number of characters in m. If k â‰¤ f, then Let z be the String value consisting of f+1â€“k occurrences of the character "0". Let m be the string-concatenation of z and m. Let k be f+1. Let a be the first kâ€“f characters of m, and let b be the remaining f characters of m. Let m be the string-concatenation of a, ".", and b. Let int be the number of characters in a. Else, let int be the number of characters in m. Let cut be maxFraction â€“ minFraction. Repeat, while cut > 0 and the last character of m is "0", Remove the last character from m. Decrease cut by 1. If the last character of m is ".", then Remove the last character from m. Return the Record { [[FormattedString]]: m, [[RoundedNumber]]: xFinal, [[IntegerDigitsCount]]: int }. 15.5.10 UnwrapNumberFormat ( nf ) The UnwrapNumberFormat abstract operation returns the NumberFormat instance of its input object, which is either the value itself or a value associated with it by %NumberFormat% according to the normative optional constructor mode of 4.3 Note 1. If Type(nf) is not Object, throw a TypeError exception. If nf does not have an [[InitializedNumberFormat]] internal slot and ? OrdinaryHasInstance(%NumberFormat%, nf) is true, then Return ? Get(nf, %Intl%.[[FallbackSymbol]]). Return nf. 15.5.11 GetNumberFormatPattern ( numberFormat, x ) The abstract operation GetNumberFormatPattern considers the resolved unit-related options in the number format object along with the final scaled and rounded number being formatted and returns a pattern, a String value as described in 15.2.3. Let localeData be %NumberFormat%.[[LocaleData]]. Let dataLocale be numberFormat.[[DataLocale]]. Let dataLocaleData be localeData.[[<dataLocale>]]. Let patterns be dataLocaleData.[[patterns]]. Assert: patterns is a Record (see 15.2.3). Let style be numberFormat.[[Style]]. If style is "percent", then Let patterns be patterns.[[percent]]. Else if style is "unit", then Let unit be numberFormat.[[Unit]]. Let unitDisplay be numberFormat.[[UnitDisplay]]. Let patterns be patterns.[[unit]]. If patterns doesn't have a field [[<unit>]], then Let unit be "fallback". Let patterns be patterns.[[<unit>]]. Let patterns be patterns.[[<unitDisplay>]]. Else if style is "currency", then Let currency be numberFormat.[[Currency]]. Let currencyDisplay be numberFormat.[[CurrencyDisplay]]. Let currencySign be numberFormat.[[CurrencySign]]. Let patterns be patterns.[[currency]]. If patterns doesn't have a field [[<currency>]], then Let currency be "fallback". Let patterns be patterns.[[<currency>]]. Let patterns be patterns.[[<currencyDisplay>]]. Let patterns be patterns.[[<currencySign>]]. Else, Assert: style is "decimal". Let patterns be patterns.[[decimal]]. Let signDisplay be numberFormat.[[SignDisplay]]. If signDisplay is "never", then Let pattern be patterns.[[zeroPattern]]. Else if signDisplay is "auto", then If x is 0 or x > 0 or x is NaN, then Let pattern be patterns.[[zeroPattern]]. Else, Let pattern be patterns.[[negativePattern]]. Else if signDisplay is "always", then If x is 0 or x > 0 or x is NaN, then Let pattern be patterns.[[positivePattern]]. Else, Let pattern be patterns.[[negativePattern]]. Else, Assert: signDisplay is "exceptZero". If x is NaN, or if x is finite and â„?(x) is 0, then Let pattern be patterns.[[zeroPattern]]. Else if â„?(x) > 0, then Let pattern be patterns.[[positivePattern]]. Else, Let pattern be patterns.[[negativePattern]]. Return pattern. 15.5.12 GetNotationSubPattern ( numberFormat, exponent ) The abstract operation GetNotationSubPattern considers the resolved notation and exponent, and returns a String value for the notation sub pattern as described in 15.2.3. Let localeData be %NumberFormat%.[[LocaleData]]. Let dataLocale be numberFormat.[[DataLocale]]. Let dataLocaleData be localeData.[[<dataLocale>]]. Let notationSubPatterns be dataLocaleData.[[notationSubPatterns]]. Assert: notationSubPatterns is a Record (see 15.2.3). Let notation be numberFormat.[[Notation]]. If notation is "scientific" or notation is "engineering", then Return notationSubPatterns.[[scientific]]. Else if exponent is not 0, then Assert: notation is "compact". Let compactDisplay be numberFormat.[[CompactDisplay]]. Let compactPatterns be notationSubPatterns.[[compact]].[[<compactDisplay>]]. Return compactPatterns.[[<exponent>]]. Else, Return "{number}". 15.5.13 ComputeExponent ( numberFormat, x ) The abstract operation ComputeExponent computes an exponent (power of ten) by which to scale x according to the number formatting settings. It handles cases such as 999 rounding up to 1000, requiring a different exponent. If x = 0, then Return 0. If x < 0, then Let x = -x. Let magnitude be the base 10 logarithm of x rounded down to the nearest integer. Let exponent be ComputeExponentForMagnitude(numberFormat, magnitude). Let x be x Ã— 10-exponent. Let formatNumberResult be FormatNumericToString(numberFormat, x). If formatNumberResult.[[RoundedNumber]] = 0, then Return exponent. Let newMagnitude be the base 10 logarithm of formatNumberResult.[[RoundedNumber]] rounded down to the nearest integer. If newMagnitude is magnitude â€“ exponent, then Return exponent. Return ComputeExponentForMagnitude(numberFormat, magnitude + 1). 15.5.14 ComputeExponentForMagnitude ( numberFormat, magnitude ) The abstract operation ComputeExponentHelper computes an exponent by which to scale a number of the given magnitude (power of ten of the most significant digit) according to the locale and the desired notation (scientific, engineering, or compact). Let notation be numberFormat.[[Notation]]. If notation is "standard", then Return 0. Else if notation is "scientific", then Return magnitude. Else if notation is "engineering", then Let thousands be the greatest integer that is not greater than magnitude / 3. Return thousands Ã— 3. Else, Assert: notation is "compact". Let exponent be an implementation- and locale-dependent (ILD) integer by which to scale a number of the given magnitude in compact notation for the current locale. Return exponent. 16 PluralRules Objects 16.1 The Intl.PluralRules Constructor The PluralRules constructor is the %PluralRules% intrinsic object and a standard built-in property of the Intl object. Behaviour common to all service constructor properties of the Intl object is specified in 9.1. 16.1.1 Intl.PluralRules ( [ locales [ , options ] ] ) When the Intl.PluralRules function is called with optional arguments locales and options, the following steps are taken: If NewTarget is undefined, throw a TypeError exception. Let pluralRules be ? OrdinaryCreateFromConstructor(NewTarget, "%PluralRules.prototype%", Â« [[InitializedPluralRules]], [[Locale]], [[Type]], [[MinimumIntegerDigits]], [[MinimumFractionDigits]], [[MaximumFractionDigits]], [[MinimumSignificantDigits]], [[MaximumSignificantDigits]], [[RoundingType]] Â»). Return ? InitializePluralRules(pluralRules, locales, options). 16.1.2 InitializePluralRules ( pluralRules, locales, options ) The abstract operation InitializePluralRules accepts the arguments pluralRules (which must be an object), locales, and options. It initializes pluralRules as a PluralRules object. The following steps are taken: Let requestedLocales be ? CanonicalizeLocaleList(locales). Set options to ? CoerceOptionsToObject(options). Let opt be a new Record. Let matcher be ? GetOption(options, "localeMatcher", "string", Â« "lookup", "best fit" Â», "best fit"). Set opt.[[localeMatcher]] to matcher. Let t be ? GetOption(options, "type", "string", Â« "cardinal", "ordinal" Â», "cardinal"). Set pluralRules.[[Type]] to t. Perform ? SetNumberFormatDigitOptions(pluralRules, options, +0ð?”½, 3ð?”½, "standard"). Let localeData be %PluralRules%.[[LocaleData]]. Let r be ResolveLocale(%PluralRules%.[[AvailableLocales]], requestedLocales, opt, %PluralRules%.[[RelevantExtensionKeys]], localeData). Set pluralRules.[[Locale]] to r.[[locale]]. Return pluralRules. 16.2 Properties of the Intl.PluralRules Constructor The Intl.PluralRules constructor has the following properties: 16.2.1 Intl.PluralRules.prototype The value of Intl.PluralRules.prototype is %PluralRules.prototype%. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 16.2.2 Intl.PluralRules.supportedLocalesOf ( locales [ , options ] ) When the supportedLocalesOf method is called with arguments locales and options, the following steps are taken: Let availableLocales be %PluralRules%.[[AvailableLocales]]. Let requestedLocales be ? CanonicalizeLocaleList(locales). Return ? SupportedLocales(availableLocales, requestedLocales, options). 16.2.3 Internal slots The value of the [[AvailableLocales]] internal slot is implementation-defined within the constraints described in 9.1. The value of the [[RelevantExtensionKeys]] internal slot is Â« Â». Note 1 Unicode Technical Standard 35 describes no locale extension keys that are relevant to the pluralization process. The value of the [[LocaleData]] internal slot is implementation-defined within the constraints described in 9.1. Note 2 It is recommended that implementations use the locale data provided by the Common Locale Data Repository (available at https://cldr.unicode.org/). 16.3 Properties of the Intl.PluralRules Prototype Object The Intl.PluralRules prototype object is itself an ordinary object. %PluralRules.prototype% is not an Intl.PluralRules instance and does not have an [[InitializedPluralRules]] internal slot or any of the other internal slots of Intl.PluralRules instance objects. 16.3.1 Intl.PluralRules.prototype.constructor The initial value of Intl.PluralRules.prototype.constructor is %PluralRules%. 16.3.2 Intl.PluralRules.prototype [ @@toStringTag ] The initial value of the @@toStringTag property is the String value "Intl.PluralRules". This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }. 16.3.3 Intl.PluralRules.prototype.select ( value ) When the select method is called with an argument value, the following steps are taken: Let pr be the this value. Perform ? RequireInternalSlot(pr, [[InitializedPluralRules]]). Let n be ? ToNumber(value). Return ! ResolvePlural(pr, n). 16.3.4 Intl.PluralRules.prototype.resolvedOptions ( ) This function provides access to the locale and options computed during initialization of the object. Let pr be the this value. Perform ? RequireInternalSlot(pr, [[InitializedPluralRules]]). Let options be ! OrdinaryObjectCreate(%Object.prototype%). For each row of Table 13, except the header row, in table order, do Let p be the Property value of the current row. Let v be the value of pr's internal slot whose name is the Internal Slot value of the current row. If v is not undefined, then Perform ! CreateDataPropertyOrThrow(options, p, v). Let pluralCategories be a List of Strings containing all possible results of PluralRuleSelect for the selected locale pr.[[Locale]]. Perform ! CreateDataProperty(options, "pluralCategories", ! CreateArrayFromList(pluralCategories)). Return options. Table 13: Resolved Options of PluralRules Instances Internal Slot Property [[Locale]] "locale" [[Type]] "type" [[MinimumIntegerDigits]] "minimumIntegerDigits" [[MinimumFractionDigits]] "minimumFractionDigits" [[MaximumFractionDigits]] "maximumFractionDigits" [[MinimumSignificantDigits]] "minimumSignificantDigits" [[MaximumSignificantDigits]] "maximumSignificantDigits" 16.4 Properties of Intl.PluralRules Instances Intl.PluralRules instances are ordinary objects that inherit properties from %PluralRules.prototype%. Intl.PluralRules instances have an [[InitializedPluralRules]] internal slot. Intl.PluralRules instances also have several internal slots that are computed by the constructor: [[Locale]] is a String value with the language tag of the locale whose localization is used by the plural rules. [[Type]] is one of the String values "cardinal" or "ordinal", identifying the plural rules used. [[MinimumIntegerDigits]] is a non-negative integer Number value indicating the minimum integer digits to be used. [[MinimumFractionDigits]] and [[MaximumFractionDigits]] are non-negative integer Number values indicating the minimum and maximum fraction digits to be used. Numbers will be rounded or padded with trailing zeroes if necessary. [[MinimumSignificantDigits]] and [[MaximumSignificantDigits]] are positive integer Number values indicating the minimum and maximum fraction digits to be used. Either none or both of these properties are present; if they are, they override minimum and maximum integer and fraction digits. [[RoundingType]] is one of the values fractionDigits or significantDigits, indicating which rounding strategy to use, as discussed in 15.4. 16.5 Abstract Operations for PluralRules Objects 16.5.1 GetOperands ( s ) The abstract operation GetOperands takes argument s (a decimal String). It extracts numeric features from s that correspond with the operands of Unicode Technical Standard #35, Part 3, Section 5.1.1. It performs the following steps when called: Let n be ! ToNumber(s). Assert: n is finite. Let dp be ! StringIndexOf(s, ".", 0). If dp = -1, then Let intPart be n. Let fracSlice be "". Else, Let intPart be the substring of s from 0 to dp. Let fracSlice be the substring of s from dp + 1. Let i be abs(! ToNumber(intPart)). Let fracDigitCount be the length of fracSlice. Let f be ! ToNumber(fracSlice). Let significantFracSlice be the value of fracSlice stripped of trailing "0". Let significantFracDigitCount be the length of significantFracSlice. Let significantFrac be ! ToNumber(significantFracSlice). Return a new Record { [[Number]]: abs(n), [[IntegerDigits]]: i, [[FractionDigits]]: f, [[NumberOfFractionDigits]]: fracDigitCount, [[FractionDigitsWithoutTrailing]]: significantFrac, [[NumberOfFractionDigitsWithoutTrailing]]: significantFracDigitCount }. Table 14: Plural Rules Operands Record Fields Internal Slot Type UTS #35 Operand Description [[Number]] Number n Absolute value of the source number [[IntegerDigits]] Number i Integer part of [[Number]]. [[FractionDigits]] Number f Visible fraction digits in [[Number]], with trailing zeroes, as an integer having [[NumberOfFractionDigits]] digits. [[NumberOfFractionDigits]] Number v Number of visible fraction digits in [[Number]], with trailing zeroes. [[FractionDigitsWithoutTrailing]] Number t Visible fraction digits in [[Number]], without trailing zeroes, as an integer having [[NumberOfFractionDigitsWithoutTrailing]] digits. [[NumberOfFractionDigitsWithoutTrailing]] Number w Number of visible fraction digits in [[Number]], without trailing zeroes. 16.5.2 PluralRuleSelect ( locale, type, n, operands ) The implementation-defined abstract operation PluralRuleSelect takes arguments locale (a String), type (a String), n (a finite Number), and operands (a Plural Rules Operands Record derived from formatting n). It returns the String from Â« "zero", "one", "two", "few", "many", "other" Â» that best categorizes the operands representation of n according to the rules for locale and type. 16.5.3 ResolvePlural ( pluralRules, n ) When the ResolvePlural abstract operation is called with arguments pluralRules (which must be an object initialized as a PluralRules) and n (which must be a Number value), it returns a String value representing the plural form of n according to the effective locale and the options of pluralRules. The following steps are taken: Assert: Type(pluralRules) is Object. Assert: pluralRules has an [[InitializedPluralRules]] internal slot. Assert: Type(n) is Number. If n is not a finite Number, then Return "other". Let locale be pluralRules.[[Locale]]. Let type be pluralRules.[[Type]]. Let res be ! FormatNumericToString(pluralRules, n). Let s be res.[[FormattedString]]. Let operands be ! GetOperands(s). Return ! PluralRuleSelect(locale, type, n, operands). 17 RelativeTimeFormat Objects 17.1 The Intl.RelativeTimeFormat Constructor The RelativeTimeFormat constructor is the %RelativeTimeFormat% intrinsic object and a standard built-in property of the Intl object. Behaviour common to all service constructor properties of the Intl object is specified in 9.1. 17.1.1 Intl.RelativeTimeFormat ( [ locales [ , options ] ] ) When the Intl.RelativeTimeFormat function is called with optional arguments locales and options, the following steps are taken: If NewTarget is undefined, throw a TypeError exception. Let relativeTimeFormat be ? OrdinaryCreateFromConstructor(NewTarget, "%RelativeTimeFormat.prototype%", Â« [[InitializedRelativeTimeFormat]], [[Locale]], [[DataLocale]], [[Style]], [[Numeric]], [[NumberFormat]], [[NumberingSystem]], [[PluralRules]] Â»). Return ? InitializeRelativeTimeFormat(relativeTimeFormat, locales, options). 17.1.2 InitializeRelativeTimeFormat ( relativeTimeFormat, locales, options ) The abstract operation InitializeRelativeTimeFormat accepts the arguments relativeTimeFormat (which must be an object), locales, and options. It initializes relativeTimeFormat as a RelativeTimeFormat object. The following algorithm refers to the type nonterminal from UTS 35's Unicode Locale Identifier grammar. The following steps are taken: Let requestedLocales be ? CanonicalizeLocaleList(locales). Set options to ? CoerceOptionsToObject(options). Let opt be a new Record. Let matcher be ? GetOption(options, "localeMatcher", "string", Â« "lookup", "best fit" Â», "best fit"). Set opt.[[LocaleMatcher]] to matcher. Let numberingSystem be ? GetOption(options, "numberingSystem", "string", undefined, undefined). If numberingSystem is not undefined, then If numberingSystem does not match the Unicode Locale Identifier type nonterminal, throw a RangeError exception. Set opt.[[nu]] to numberingSystem. Let localeData be %RelativeTimeFormat%.[[LocaleData]]. Let r be ResolveLocale(%RelativeTimeFormat%.[[AvailableLocales]], requestedLocales, opt, %RelativeTimeFormat%.[[RelevantExtensionKeys]], localeData). Let locale be r.[[locale]]. Set relativeTimeFormat.[[Locale]] to locale. Set relativeTimeFormat.[[DataLocale]] to r.[[dataLocale]]. Set relativeTimeFormat.[[NumberingSystem]] to r.[[nu]]. Let style be ? GetOption(options, "style", "string", Â« "long", "short", "narrow" Â», "long"). Set relativeTimeFormat.[[Style]] to style. Let numeric be ? GetOption(options, "numeric", "string", Â« "always", "auto" Â», "always"). Set relativeTimeFormat.[[Numeric]] to numeric. Let relativeTimeFormat.[[NumberFormat]] be ! Construct(%NumberFormat%, Â« locale Â»). Let relativeTimeFormat.[[PluralRules]] be ! Construct(%PluralRules%, Â« locale Â»). Return relativeTimeFormat. 17.2 Properties of the Intl.RelativeTimeFormat Constructor The Intl.RelativeTimeFormat constructor has the following properties: 17.2.1 Intl.RelativeTimeFormat.prototype The value of Intl.RelativeTimeFormat.prototype is %RelativeTimeFormat.prototype%. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 17.2.2 Intl.RelativeTimeFormat.supportedLocalesOf ( locales [ , options ] ) When the supportedLocalesOf method is called with arguments locales and options, the following steps are taken: Let availableLocales be %RelativeTimeFormat%.[[AvailableLocales]]. Let requestedLocales be ? CanonicalizeLocaleList(locales). Return ? SupportedLocales(availableLocales, requestedLocales, options). 17.2.3 Internal slots The value of the [[AvailableLocales]] internal slot is implementation-defined within the constraints described in 9.1. The value of the [[RelevantExtensionKeys]] internal slot is Â« "nu" Â». Note 1 Unicode Technical Standard 35 describes one locale extension key that is relevant to relative time formatting: "nu" for numbering system (of formatted numbers). The value of the [[LocaleData]] internal slot is implementation-defined within the constraints described in 9.1 and the following additional constraints, for all locale values locale: [[LocaleData]].[[<locale>]] has fields "second", "minute", "hour", "day", "week", "month", "quarter", and "year". Additional fields may exist with the previous names concatenated with the strings "-narrow" or "-short". The values corresponding to these fields are Records which contain these two categories of fields: "future" and "past" fields, which are Records with a field for each of the plural categories relevant for locale. The value corresponding to those fields is a pattern which may contain "{0}" to be replaced by a formatted number. Optionally, additional fields whose key is the result of ToString of a Number, and whose values are literal Strings which are not treated as templates. The list that is the value of the "nu" field of any locale field of [[LocaleData]] must not include the values "native", "traditio", or "finance". Note 2 It is recommended that implementations use the locale data provided by the Common Locale Data Repository (available at https://cldr.unicode.org/). 17.3 Properties of the Intl.RelativeTimeFormat Prototype Object The Intl.RelativeTimeFormat prototype object is itself an ordinary object. %RelativeTimeFormat.prototype% is not an Intl.RelativeTimeFormat instance and does not have an [[InitializedRelativeTimeFormat]] internal slot or any of the other internal slots of Intl.RelativeTimeFormat instance objects. 17.3.1 Intl.RelativeTimeFormat.prototype.constructor The initial value of Intl.RelativeTimeFormat.prototype.constructor is %RelativeTimeFormat%. 17.3.2 Intl.RelativeTimeFormat.prototype[ @@toStringTag ] The initial value of the @@toStringTag property is the String value "Intl.RelativeTimeFormat". This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }. 17.3.3 Intl.RelativeTimeFormat.prototype.format ( value, unit ) When the format method is called with arguments value and unit, the following steps are taken: Let relativeTimeFormat be the this value. Perform ? RequireInternalSlot(relativeTimeFormat, [[InitializedRelativeTimeFormat]]). Let value be ? ToNumber(value). Let unit be ? ToString(unit). Return ? FormatRelativeTime(relativeTimeFormat, value, unit). 17.3.4 Intl.RelativeTimeFormat.prototype.formatToParts ( value, unit ) When the formatToParts method is called with arguments value and unit, the following steps are taken: Let relativeTimeFormat be the this value. Perform ? RequireInternalSlot(relativeTimeFormat, [[InitializedRelativeTimeFormat]]). Let value be ? ToNumber(value). Let unit be ? ToString(unit). Return ? FormatRelativeTimeToParts(relativeTimeFormat, value, unit). 17.3.5 Intl.RelativeTimeFormat.prototype.resolvedOptions ( ) This function provides access to the locale and options computed during initialization of the object. Let relativeTimeFormat be the this value. Perform ? RequireInternalSlot(relativeTimeFormat, [[InitializedRelativeTimeFormat]]). Let options be ! OrdinaryObjectCreate(%Object.prototype%). For each row of Table 15, except the header row, in table order, do Let p be the Property value of the current row. Let v be the value of relativeTimeFormat's internal slot whose name is the Internal Slot value of the current row. Assert: v is not undefined. Perform ! CreateDataPropertyOrThrow(options, p, v). Return options. Table 15: Resolved Options of RelativeTimeFormat Instances Internal Slot Property [[Locale]] "locale" [[Style]] "style" [[Numeric]] "numeric" [[NumberingSystem]] "numberingSystem" 17.4 Properties of Intl.RelativeTimeFormat Instances Intl.RelativeTimeFormat instances are ordinary objects that inherit properties from %RelativeTimeFormat.prototype%. Intl.RelativeTimeFormat instances have an [[InitializedRelativeTimeFormat]] internal slot. Intl.RelativeTimeFormat instances also have several internal slots that are computed by the constructor: [[Locale]] is a String value with the language tag of the locale whose localization is used for formatting. [[DataLocale]] is a String value with the language tag of the nearest locale for which the implementation has data to perform the formatting operation. It will be a parent locale of [[Locale]]. [[Style]] is one of the String values "long", "short", or "narrow", identifying the relative time format style used. [[Numeric]] is one of the String values "always" or "auto", identifying whether numerical descriptions are always used, or used only when no more specific version is available (e.g., "1 day ago" vs "yesterday"). [[NumberFormat]] is an Intl.NumberFormat object used for formatting. [[NumberingSystem]] is a String value with the "type" given in Unicode Technical Standard 35 for the numbering system used for formatting. [[PluralRules]] is an Intl.PluralRules object used for formatting. 17.5 Abstract Operations for RelativeTimeFormat Objects 17.5.1 SingularRelativeTimeUnit ( unit ) Assert: Type(unit) is String. If unit is "seconds", return "second". If unit is "minutes", return "minute". If unit is "hours", return "hour". If unit is "days", return "day". If unit is "weeks", return "week". If unit is "months", return "month". If unit is "quarters", return "quarter". If unit is "years", return "year". If unit is not one of "second", "minute", "hour", "day", "week", "month", "quarter", or "year", throw a RangeError exception. Return unit. 17.5.2 PartitionRelativeTimePattern ( relativeTimeFormat, value, unit ) When the PartitionRelativeTimePattern abstract operation is called with arguments relativeTimeFormat, value, and unit it returns a String value representing value (which must be a Number value) according to the effective locale and the formatting options of relativeTimeFormat. Assert: relativeTimeFormat has an [[InitializedRelativeTimeFormat]] internal slot. Assert: Type(value) is Number. Assert: Type(unit) is String. If value is NaN, +âˆžð?”½, or -âˆžð?”½, throw a RangeError exception. Let unit be ? SingularRelativeTimeUnit(unit). Let localeData be %RelativeTimeFormat%.[[LocaleData]]. Let dataLocale be relativeTimeFormat.[[DataLocale]]. Let fields be localeData.[[<dataLocale>]]. Let style be relativeTimeFormat.[[Style]]. If style is equal to "short", then Let entry be the string-concatenation of unit and "-short". Else if style is equal to "narrow", then Let entry be the string-concatenation of unit and "-narrow". Else, Let entry be unit. If fields doesn't have a field [[<entry>]], then Let entry be unit. Let patterns be fields.[[<entry>]]. Let numeric be relativeTimeFormat.[[Numeric]]. If numeric is equal to "auto", then Let valueString be ToString(value). If patterns has a field [[<valueString>]], then Let result be patterns.[[<valueString>]]. Return a List containing the Record { [[Type]]: "literal", [[Value]]: result }. If value is -0ð?”½ or if value is less than 0, then Let tl be "past". Else, Let tl be "future". Let po be patterns.[[<tl>]]. Let fv be ! PartitionNumberPattern(relativeTimeFormat.[[NumberFormat]], value). Let pr be ! ResolvePlural(relativeTimeFormat.[[PluralRules]], value). Let pattern be po.[[<pr>]]. Return ! MakePartsList(pattern, unit, fv). 17.5.3 MakePartsList ( pattern, unit, parts ) The MakePartsList abstract operation is called with arguments pattern, a pattern String, unit, a String, and parts, a List of Records representing a formatted Number. Note Example: Return ! MakePartsList("AA{0}BB", "hour", Â« Record { [[Type]]: "integer", [[Value]]: "15" } Â»). will return a List of Records like Â« { [[Type]]: "literal", [[Value]]: "AA", [[Unit]]: empty}, { [[Type]]: "integer", [[Value]]: "15", [[Unit]]: "hour"}, { [[Type]]: "literal", [[Value]]: "BB", [[Unit]]: empty} Â» Let patternParts be PartitionPattern(pattern). Let result be a new empty List. For each Record { [[Type]], [[Value]] } patternPart in patternParts, do If patternPart.[[Type]] is "literal", then Append Record { [[Type]]: "literal", [[Value]]: patternPart.[[Value]], [[Unit]]: empty } to result. Else, Assert: patternPart.[[Type]] is "0". For each Record { [[Type]], [[Value]] } part in parts, do Append Record { [[Type]]: part.[[Type]], [[Value]]: part.[[Value]], [[Unit]]: unit } to result. Return result. 17.5.4 FormatRelativeTime ( relativeTimeFormat, value, unit ) The FormatRelativeTime abstract operation is called with arguments relativeTimeFormat (which must be an object initialized as a RelativeTimeFormat), value (which must be a Number value), and unit (which must be a String denoting the value unit) and performs the following steps: Let parts be ? PartitionRelativeTimePattern(relativeTimeFormat, value, unit). Let result be an empty String. For each Record { [[Type]], [[Value]], [[Unit]] } part in parts, do Set result to the string-concatenation of result and part.[[Value]]. Return result. 17.5.5 FormatRelativeTimeToParts ( relativeTimeFormat, value, unit ) The FormatRelativeTimeToParts abstract operation is called with arguments relativeTimeFormat (which must be an object initialized as a RelativeTimeFormat), value (which must be a Number value), and unit (which must be a String denoting the value unit) and performs the following steps: Let parts be ? PartitionRelativeTimePattern(relativeTimeFormat, value, unit). Let result be ! ArrayCreate(0). Let n be 0. For each Record { [[Type]], [[Value]], [[Unit]] } part in parts, do Let O be ! OrdinaryObjectCreate(%Object.prototype%). Perform ! CreateDataPropertyOrThrow(O, "type", part.[[Type]]). Perform ! CreateDataPropertyOrThrow(O, "value", part.[[Value]]). If part.[[Unit]] is not empty, then Perform ! CreateDataPropertyOrThrow(O, "unit", part.[[Unit]]). Perform ! CreateDataPropertyOrThrow(result, ! ToString(n), O). Increment n by 1. Return result. 18 Segmenter Objects 18.1 The Intl.Segmenter Constructor The Segmenter constructor is the %Segmenter% intrinsic object and a standard built-in property of the Intl object. Behaviour common to all service constructor properties of the Intl object is specified in 9.1. 18.1.1 Intl.Segmenter ( [ locales [ , options ] ] ) When the Intl.Segmenter function is called with optional arguments locales and options, the following steps are taken: If NewTarget is undefined, throw a TypeError exception. Let internalSlotsList be Â« [[InitializedSegmenter]], [[Locale]], [[SegmenterGranularity]] Â». Let segmenter be ? OrdinaryCreateFromConstructor(NewTarget, "%Segmenter.prototype%", internalSlotsList). Let requestedLocales be ? CanonicalizeLocaleList(locales). Set options to ? GetOptionsObject(options). Let opt be a new Record. Let matcher be ? GetOption(options, "localeMatcher", "string", Â« "lookup", "best fit" Â», "best fit"). Set opt.[[localeMatcher]] to matcher. Let localeData be %Segmenter%.[[LocaleData]]. Let r be ResolveLocale(%Segmenter%.[[AvailableLocales]], requestedLocales, opt, %Segmenter%.[[RelevantExtensionKeys]], localeData). Set segmenter.[[Locale]] to r.[[locale]]. Let granularity be ? GetOption(options, "granularity", "string", Â« "grapheme", "word", "sentence" Â», "grapheme"). Set segmenter.[[SegmenterGranularity]] to granularity. Return segmenter. 18.2 Properties of the Intl.Segmenter Constructor The Intl.Segmenter constructor has the following properties: 18.2.1 Intl.Segmenter.prototype The value of Intl.Segmenter.prototype is %Segmenter.prototype%. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 18.2.2 Intl.Segmenter.supportedLocalesOf ( locales [ , options ] ) When the supportedLocalesOf method is called with arguments locales and options, the following steps are taken: Let availableLocales be %Segmenter%.[[AvailableLocales]]. Let requestedLocales be ? CanonicalizeLocaleList(locales). Return ? SupportedLocales(availableLocales, requestedLocales, options). 18.2.3 Internal slots The value of the [[AvailableLocales]] internal slot is implementation-defined within the constraints described in 9.1. The value of the [[RelevantExtensionKeys]] internal slot is Â« Â». Note Intl.Segmenter does not have any relevant extension keys. The value of the [[LocaleData]] internal slot is implementation-defined within the constraints described in 9.1. 18.3 Properties of the Intl.Segmenter Prototype Object The Intl.Segmenter prototype object is itself an ordinary object. %Segmenter.prototype% is not an Intl.Segmenter instance and does not have an [[InitializedSegmenter]] internal slot or any of the other internal slots of Intl.Segmenter instance objects. 18.3.1 Intl.Segmenter.prototype.constructor The initial value of Intl.Segmenter.prototype.constructor is %Segmenter%. 18.3.2 Intl.Segmenter.prototype [ @@toStringTag ] The initial value of the @@toStringTag property is the String value "Intl.Segmenter". This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }. 18.3.3 Intl.Segmenter.prototype.segment ( string ) The Intl.Segmenter.prototype.segment method is called on an Intl.Segmenter instance with argument string to create a Segments instance for the string using the locale and options of the Intl.Segmenter instance. The following steps are taken: Let segmenter be the this value. Perform ? RequireInternalSlot(segmenter, [[InitializedSegmenter]]). Let string be ? ToString(string). Return ! CreateSegmentsObject(segmenter, string). 18.3.4 Intl.Segmenter.prototype.resolvedOptions ( ) This function provides access to the locale and options computed during initialization of the object. Let segmenter be the this value. Perform ? RequireInternalSlot(segmenter, [[InitializedSegmenter]]). Let options be ! OrdinaryObjectCreate(%Object.prototype%). For each row of Table 16, except the header row, in table order, do Let p be the Property value of the current row. Let v be the value of segmenter's internal slot whose name is the Internal Slot value of the current row. Assert: v is not undefined. Perform ! CreateDataPropertyOrThrow(options, p, v). Return options. Table 16: Resolved Options of Segmenter Instances Internal Slot Property [[Locale]] "locale" [[SegmenterGranularity]] "granularity" 18.4 Properties of Intl.Segmenter Instances Intl.Segmenter instances are ordinary objects that inherit properties from %Segmenter.prototype%. Intl.Segmenter instances have an [[InitializedSegmenter]] internal slot. Intl.Segmenter instances also have internal slots that are computed by the constructor: [[Locale]] is a String value with the language tag of the locale whose localization is used for segmentation. [[SegmenterGranularity]] is one of the String values "grapheme", "word", or "sentence", identifying the kind of text element to segment. 18.5 Segments Objects A Segments instance is an object that represents the segments of a specific string, subject to the locale and options of its constructing Intl.Segmenter instance. 18.5.1 CreateSegmentsObject ( segmenter, string ) The CreateSegmentsObject abstract operation is called with arguments Intl.Segmenter instance segmenter and String value string to create a Segments instance referencing both. The following steps are taken: Let internalSlotsList be Â« [[SegmentsSegmenter]], [[SegmentsString]] Â». Let segments be ! OrdinaryObjectCreate(%SegmentsPrototype%, internalSlotsList). Set segments.[[SegmentsSegmenter]] to segmenter. Set segments.[[SegmentsString]] to string. Return segments. 18.5.2 The %SegmentsPrototype% Object The %SegmentsPrototype% object: is the prototype of all Segments objects. is an ordinary object. has the following properties: 18.5.2.1 %SegmentsPrototype%.containing ( index ) The containing method is called on a Segments instance with argument index to return a Segment Data object describing the segment in the string including the code unit at the specified index according to the locale and options of the Segments intance's constructing Intl.Segmenter instance. The following steps are taken: Let segments be the this value. Perform ? RequireInternalSlot(segments, [[SegmentsSegmenter]]). Let segmenter be segments.[[SegmentsSegmenter]]. Let string be segments.[[SegmentsString]]. Let len be the length of string. Let n be ? ToIntegerOrInfinity(index). If n < 0 or n â‰¥ len, return undefined. Let startIndex be ! FindBoundary(segmenter, string, n, before). Let endIndex be ! FindBoundary(segmenter, string, n, after). Return ! CreateSegmentDataObject(segmenter, string, startIndex, endIndex). 18.5.2.2 %SegmentsPrototype% [ @@iterator ] ( ) The @@iterator method is called on a Segments instance to create a Segment Iterator over its string using the locale and options of its constructing Intl.Segmenter instance. The following steps are taken: Let segments be the this value. Perform ? RequireInternalSlot(segments, [[SegmentsSegmenter]]). Let segmenter be segments.[[SegmentsSegmenter]]. Let string be segments.[[SegmentsString]]. Return ! CreateSegmentIterator(segmenter, string). 18.5.3 Properties of Segments Instances Segments instances are ordinary objects that inherit properties from %SegmentsPrototype%. Segments instances have a [[SegmentsSegmenter]] internal slot that references the constructing Intl.Segmenter instance. Segments instances have a [[SegmentsString]] internal slot that references the String value whose segments they expose. 18.6 Segment Iterator Objects A Segment Iterator is an object that represents a particular iteration over the segments of a specific string. 18.6.1 CreateSegmentIterator ( segmenter, string ) The CreateSegmentIterator abstract operation is called with arguments Intl.Segmenter instance segmenter and String value string to create a Segment Iterator over string using the locale and options of segmenter. The following steps are taken: Let internalSlotsList be Â« [[IteratingSegmenter]], [[IteratedString]], [[IteratedStringNextSegmentCodeUnitIndex]] Â». Let iterator be ! OrdinaryObjectCreate(%SegmentIteratorPrototype%, internalSlotsList). Set iterator.[[IteratingSegmenter]] to segmenter. Set iterator.[[IteratedString]] to string. Set iterator.[[IteratedStringNextSegmentCodeUnitIndex]] to 0. Return iterator. 18.6.2 The %SegmentIteratorPrototype% Object The %SegmentIteratorPrototype% object: is the prototype of all Segment Iterator objects. is an ordinary object. has a [[Prototype]] internal slot whose value is the intrinsic object %Iterator.prototype%. has the following properties: 18.6.2.1 %SegmentIteratorPrototype%.next ( ) The next method is called on a Segment Iterator instance to advance it forward one segment and return an IteratorResult object either describing the new segment or declaring iteration done. The following steps are taken: Let iterator be the this value. Perform ? RequireInternalSlot(iterator, [[IteratingSegmenter]]). Let segmenter be iterator.[[IteratingSegmenter]]. Let string be iterator.[[IteratedString]]. Let startIndex be iterator.[[IteratedStringNextSegmentCodeUnitIndex]]. Let endIndex be ! FindBoundary(segmenter, string, startIndex, after). If endIndex is not finite, then Return ! CreateIterResultObject(undefined, true). Set iterator.[[IteratedStringNextSegmentCodeUnitIndex]] to endIndex. Let segmentData be ! CreateSegmentDataObject(segmenter, string, startIndex, endIndex). Return ! CreateIterResultObject(segmentData, false). 18.6.2.2 %SegmentIteratorPrototype% [ @@toStringTag ] The initial value of the @@toStringTag property is the String value "Segmenter String Iterator". This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }. 18.6.3 Properties of Segment Iterator Instances Segment Iterator instances are ordinary objects that inherit properties from %SegmentIteratorPrototype%. Segment Iterator instances are initially created with the internal slots described in Table 17. Table 17: Internal Slots of Segment Iterator Instances Internal Slot Description [[IteratingSegmenter]] The Intl.Segmenter instance used for iteration. [[IteratedString]] The String value being iterated upon. [[IteratedStringNextSegmentCodeUnitIndex]] The code unit index in the String value being iterated upon at the start of the next segment. 18.7 Segment Data Objects A Segment Data object is an object that represents a particular segment from a string. 18.7.1 CreateSegmentDataObject ( segmenter, string, startIndex, endIndex ) The CreateSegmentDataObject abstract operation is called with arguments Intl.Segmenter instance segmenter, String value string, and indices startIndex and endIndex within string to create a Segment Data object describing the segment within string from segmenter that is bounded by the indices. The following steps are taken: Let len be the length of string. Assert: startIndex â‰¥ 0. Assert: endIndex â‰¤ len. Assert: startIndex < endIndex. Let result be ! OrdinaryObjectCreate(%Object.prototype%). Let segment be the substring of string from startIndex to endIndex. Perform ! CreateDataPropertyOrThrow(result, "segment", segment). Perform ! CreateDataPropertyOrThrow(result, "index", ð?”½(startIndex)). Perform ! CreateDataPropertyOrThrow(result, "input", string). Let granularity be segmenter.[[SegmenterGranularity]]. If granularity is "word", then Let isWordLike be a Boolean value indicating whether the segment in string is "word-like" according to locale segmenter.[[Locale]]. Perform ! CreateDataPropertyOrThrow(result, "isWordLike", isWordLike). Return result. Note Whether a segment is "word-like" is implementation-dependent, and implementations are recommended to use locale-sensitive tailorings. In general, segments consisting solely of spaces and/or punctuation (such as those terminated with "WORD_NONE" boundaries by ICU [International Components for Unicode, documented at https://unicode-org.github.io/icu-docs/]) are not considered to be "word-like". 18.8 Abstract Operations for Segmenter Objects 18.8.1 FindBoundary ( segmenter, string, startIndex, direction ) The FindBoundary abstract operation is called with arguments Intl.Segmenter instance segmenter, String string, integer startIndex, and direction (which must be before or after) to find a segmentation boundary between two code units in string in the specified direction from the code unit at index startIndex according to the locale and options of segmenter and return the immediately following code unit index (which will be infinite if no such boundary exists). The following steps are taken: Note Boundary determination is implementation-dependent, but general default algorithms are specified in Unicode Standard Annex 29 (available at https://www.unicode.org/reports/tr29/). It is recommended that implementations use locale-sensitive tailorings such as those provided by the Common Locale Data Repository (available at http://cldr.unicode.org). Let locale be segmenter.[[Locale]]. Let granularity be segmenter.[[SegmenterGranularity]]. Let len be the length of string. If direction is before, then Assert: startIndex â‰¥ 0. Assert: startIndex < len. Search string for the last segmentation boundary that is preceded by at most startIndex code units from the beginning, using locale locale and text element granularity granularity. If a boundary is found, return the count of code units in string preceding it. Return 0. Assert: direction is after. If len is 0 or startIndex â‰¥ len, return +âˆž. Search string for the first segmentation boundary that follows the code unit at index startIndex, using locale locale and text element granularity granularity. If a boundary is found, return the count of code units in string preceding it. Return len. 19 Locale Sensitive Functions of the ECMAScript Language Specification The ECMAScript Language Specification, edition 10 or successor, describes several locale-sensitive functions. An ECMAScript implementation that implements this Internationalization API Specification shall implement these functions as described here. Note The Collator, NumberFormat, or DateTimeFormat objects created in the algorithms in this clause are only used within these algorithms. They are never directly accessed by ECMAScript code and need not actually exist within an implementation. 19.1 Properties of the String Prototype Object 19.1.1 String.prototype.localeCompare ( that [ , locales [ , options ] ] ) This definition supersedes the definition provided in es2023, 21.1.3.10. When the localeCompare method is called with argument that and optional arguments locales, and options, the following steps are taken: Let O be ? RequireObjectCoercible(this value). Let S be ? ToString(O). Let thatValue be ? ToString(that). Let collator be ? Construct(%Collator%, Â« locales, options Â»). Return CompareStrings(collator, S, thatValue). The value of the "length" property of the localeCompare method is 1. Note 1 The localeCompare method itself is not directly suitable as an argument to Array.prototype.sort because the latter requires a function of two arguments. Note 2 The localeCompare function is intentionally generic; it does not require that its this value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method. 19.1.2 String.prototype.toLocaleLowerCase ( [ locales ] ) This definition supersedes the definition provided in es2023, 21.1.3.23. This function interprets a String value as a sequence of code points, as described in es2023, 6.1.4. The following steps are taken: Let O be ? RequireObjectCoercible(this value). Let S be ? ToString(O). Return ? TransformCase(S, locales, lower). Note The toLocaleLowerCase function is intentionally generic; it does not require that its this value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method. 19.1.2.1 TransformCase ( S, locales, targetCase ) The abstract operation TransformCase takes arguments S (a String), locales (an ECMAScript language value), and targetCase (lower or upper). It interprets S as a sequence of UTF-16 encoded code points, as described in 6.1.4, and returns the result of implementation- and locale-dependent (ILD) transformation into targetCase as a new String value. It performs the following steps when called: Let requestedLocales be ? CanonicalizeLocaleList(locales). If requestedLocales is not an empty List, then Let requestedLocale be requestedLocales[0]. Else, Let requestedLocale be ! DefaultLocale(). Let noExtensionsLocale be the String value that is requestedLocale with any Unicode locale extension sequences (6.2.1) removed. Let availableLocales be a List with language tags that includes the languages for which the Unicode Character Database contains language sensitive case mappings. Implementations may add additional language tags if they support case mapping for additional locales. Let locale be ! BestAvailableLocale(availableLocales, noExtensionsLocale). If locale is undefined, set locale to "und". Let codePoints be ! StringToCodePoints(S). If targetCase is lower, then Let newCodePoints be a List whose elements are the result of a lowercase transformation of codePoints according to an implementation-derived algorithm using locale or the Unicode Default Case Conversion algorithm. Else, Assert: targetCase is upper. Let newCodePoints be a List whose elements are the result of an uppercase transformation of codePoints according to an implementation-derived algorithm using locale or the Unicode Default Case Conversion algorithm. Return ! CodePointsToString(newCodePoints). Code point mappings may be derived according to a tailored version of the Default Case Conversion Algorithms of the Unicode Standard. Implementations may use locale-sensitive tailoring defined in the file SpecialCasing.txt of the Unicode Character Database and/or CLDR and/or any other custom tailoring. Regardless of tailoring, a conforming implementation's case transformation algorithm must always yield the same result given the same input code points, locale, and target case. Note The case mapping of some code points may produce multiple code points, and therefore the result may not be the same length as the input. Because both toLocaleUpperCase and toLocaleLowerCase have context-sensitive behaviour, the functions are not symmetrical. In other words, s.toLocaleUpperCase().toLocaleLowerCase() is not necessarily equal to s.toLocaleLowerCase() and s.toLocaleLowerCase().toLocaleUpperCase() is not necessarily equal to s.toLocaleUpperCase(). 19.1.3 String.prototype.toLocaleUpperCase ( [ locales ] ) This definition supersedes the definition provided in es2023, 21.1.3.24. This function interprets a String value as a sequence of code points, as described in es2023, 6.1.4. The following steps are taken: Let O be ? RequireObjectCoercible(this value). Let S be ? ToString(O). Return ? TransformCase(S, locales, upper). Note The toLocaleUpperCase function is intentionally generic; it does not require that its this value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method. 19.2 Properties of the Number Prototype Object The following definition(s) refer to the abstract operation thisNumberValue as defined in es2023, 20.1.3. 19.2.1 Number.prototype.toLocaleString ( [ locales [ , options ] ] ) This definition supersedes the definition provided in es2023, 20.1.3.4. When the toLocaleString method is called with optional arguments locales and options, the following steps are taken: Let x be ? thisNumberValue(this value). Let numberFormat be ? Construct(%NumberFormat%, Â« locales, options Â»). Return ? FormatNumeric(numberFormat, x). 19.3 Properties of the BigInt Prototype Object The following definition(s) refer to the abstract operation thisBigIntValue as defined in es2023, 20.2.3. 19.3.1 BigInt.prototype.toLocaleString ( [ locales [ , options ] ] ) This definition supersedes the definition provided in es2023, 20.2.3.2. When the toLocaleString method is called with optional arguments locales and options, the following steps are taken: Let x be ? thisBigIntValue(this value). Let numberFormat be ? Construct(%NumberFormat%, Â« locales, options Â»). Return ? FormatNumeric(numberFormat, x). 19.4 Properties of the Date Prototype Object The following definition(s) refer to the abstract operation thisTimeValue as defined in es2023, 20.4.4. 19.4.1 Date.prototype.toLocaleString ( [ locales [ , options ] ] ) This definition supersedes the definition provided in es2023, 20.4.4.39. When the toLocaleString method is called with optional arguments locales and options, the following steps are taken: Let x be ? thisTimeValue(this value). If x is NaN, return "Invalid Date". Let options be ? ToDateTimeOptions(options, "any", "all"). Let dateFormat be ? Construct(%DateTimeFormat%, Â« locales, options Â»). Return ? FormatDateTime(dateFormat, x). 19.4.2 Date.prototype.toLocaleDateString ( [ locales [ , options ] ] ) This definition supersedes the definition provided in es2023, 20.4.4.38. When the toLocaleDateString method is called with optional arguments locales and options, the following steps are taken: Let x be ? thisTimeValue(this value). If x is NaN, return "Invalid Date". Let options be ? ToDateTimeOptions(options, "date", "date"). Let dateFormat be ? Construct(%DateTimeFormat%, Â« locales, options Â»). Return ? FormatDateTime(dateFormat, x). 19.4.3 Date.prototype.toLocaleTimeString ( [ locales [ , options ] ] ) This definition supersedes the definition provided in es2023, 20.4.4.40. When the toLocaleTimeString method is called with optional arguments locales and options, the following steps are taken: Let x be ? thisTimeValue(this value). If x is NaN, return "Invalid Date". Let options be ? ToDateTimeOptions(options, "time", "time"). Let timeFormat be ? Construct(%DateTimeFormat%, Â« locales, options Â»). Return ? FormatDateTime(timeFormat, x). 19.5 Properties of the Array Prototype Object 19.5.1 Array.prototype.toLocaleString ( [ locales [ , options ] ] ) This definition supersedes the definition provided in es2023, 22.1.3.29. When the toLocaleString method is called with optional arguments locales and options, the following steps are taken: Let array be ? ToObject(this value). Let len be ? ToLength(? Get(array, "length")). Let separator be the implementation-defined list-separator String value appropriate for the host environment's current locale (such as ", "). Let R be the empty String. Let k be 0. Repeat, while k < len, If k > 0, then Set R to the string-concatenation of R and separator. Let nextElement be ? Get(array, ! ToString(k)). If nextElement is not undefined or null, then Let S be ? ToString(? Invoke(nextElement, "toLocaleString", Â« locales, options Â»)). Set R to the string-concatenation of R and S. Increase k by 1. Return R. Note 1 This algorithm's steps mirror the steps taken in 22.1.3.29, with the exception that Invoke(nextElement, "toLocaleString") now takes locales and options as arguments. Note 2 The elements of the array are converted to Strings using their toLocaleString methods, and these Strings are then concatenated, separated by occurrences of an implementation-defined locale-sensitive separator String. This function is analogous to toString except that it is intended to yield a locale-sensitive result corresponding with conventions of the host environment's current locale. Note 3 The toLocaleString function is intentionally generic; it does not require that its this value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method. A Implementation Dependent Behaviour The following aspects of the ECMAScript 2023 Internationalization API Specification are implementation dependent: In all functionality: Additional values for some properties of options arguments (2) The default locale (6.2.4) The default time zone (6.4.3) The set of available locales for each constructor (9.1) The BestFitMatcher algorithm (9.2.4) The BestFitSupportedLocales algorithm (9.2.9) In Collator: Support for the Unicode extensions keys "kf", "kn" and the parallel options properties "caseFirst", "numeric" (10.1.2) The set of supported "co" key values (collations) per locale beyond a default collation (10.2.3) The set of supported "kf" key values (case order) per locale (10.2.3) The set of supported "kn" key values (numeric collation) per locale (10.2.3) The default search sensitivity per locale (10.2.3) The sort order for each supported locale and options combination (10.3.3.1) In DateTimeFormat: The BestFitFormatMatcher algorithm (11.1.2) The set of supported "ca" key values (calendars) per locale (11.2.3) The set of supported "nu" key values (numbering systems) per locale (11.2.3) The default hourCycle setting per locale (11.2.3) The set of supported date-time formats per locale beyond a core set, including the representations used for each component and the associated patterns (11.2.3) Localized weekday names, era names, month names, day period names, am/pm indicators, and time zone names (11.5.8) The calendric calculations used for calendars other than "gregory", and adjustments for local time zones and daylight saving time (11.5.8) The set of all known registered Zone and Link names of the IANA Time Zone Database and the information about their offsets from UTC and their daylight saving time rules (6.4) In DisplayNames: The localized names (12.2.3) In ListFormat: The patterns used for formatting values (13.2.3) In Locale: Support for the Unicode extensions keys "kf", "kn" and the parallel options properties "caseFirst", "numeric" (14.1.1) In NumberFormat: The set of supported "nu" key values (numbering systems) per locale (15.2.3) The patterns used for formatting values as decimal, percent, currency, or unit values per locale, with or without the sign, with or without accounting format for currencies, and in standard, compact, or scientific notation (15.5.6) Localized representations of NaN and Infinity (15.5.6) The implementation of numbering systems not listed in Table 12 (15.5.6) Localized decimal and grouping separators (15.5.6) Localized plus and minus signs (15.5.6) Localized digit grouping schemata (15.5.6) Localized magnitude thresholds for compact notation (15.5.6) Localized symbols for compact and scientific notation (15.5.6) Localized narrow, short, and long currency symbols and names (15.5.6) Localized narrow, short, and long unit symbols (15.5.6) In PluralRules: List of Strings representing the possible results of plural selection and their corresponding order per locale. (16.1.2) In RelativeTimeFormat: The set of supported "nu" key values (numbering systems) per locale (17.2.3) The patterns used for formatting values (17.2.3) In Segmenter: Boundary determination algorithms (18.8.1) Classification of segments as "word-like" (18.7.1) B Additions and Changes That Introduce Incompatibilities with Prior Editions 10.1, 15.1, 11.1 In ECMA-402, 1st Edition, constructors could be used to create Intl objects from arbitrary objects. This is no longer possible in 2nd Edition. 11.3.3 In ECMA-402, 1st Edition, the "length" property of the function object F was set to +0ð?”½. In 2nd Edition, "length" is set to 1ð?”½. 10.3.2 In ECMA-402, 7th Edition, the @@toStringTag property of Intl.Collator.prototype was set to "Object". In 8th Edition, @@toStringTag is set to "Intl.Collator". 11.3.2 In ECMA-402, 7th Edition, the @@toStringTag property of Intl.DateTimeFormat.prototype was set to "Object". In 8th Edition, @@toStringTag is set to "Intl.DateTimeFormat". 15.3.2 In ECMA-402, 7th Edition, the @@toStringTag property of Intl.NumberFormat.prototype was set to "Object". In 8th Edition, @@toStringTag is set to "Intl.NumberFormat". 16.3.2 In ECMA-402, 7th Edition, the @@toStringTag property of Intl.PluralRules.prototype was set to "Object". In 8th Edition, @@toStringTag is set to "Intl.PluralRules". 8.1.1 In ECMA-402, 7th Edition, the @@toStringTag property of Intl was not defined. In 8th Edition, @@toStringTag is set to "Intl". 15.1 In ECMA-402, 8th Edition, the NumberFormat constructor used to throw an error when style is "currency" and maximumFractionDigits was set to a value lower than the default fractional digits for that currency. This behaviour was corrected in the 9th edition, and it no longer throws an error. C Colophon This specification is authored on GitHub in a plaintext source format called Ecmarkup. Ecmarkup is an HTML and Markdown dialect that provides a framework and toolset for authoring ECMAScript specifications in plaintext and processing the specification into a full-featured HTML rendering that follows the editorial conventions for this document. Ecmarkup builds on and integrates a number of other formats and technologies including Grammarkdown for defining syntax and Ecmarkdown for authoring algorithm steps. PDF renderings of this specification are produced by printing the HTML rendering to a PDF. Prior editions of this specification were authored using Wordâ€”the Ecmarkup source text that formed the basis of this edition was produced by converting the ECMAScript 2015 Word document to Ecmarkup using an automated conversion tool. D Copyright & Software License Ecma International Rue du Rhone 114 CH-1204 Geneva Tel: +41 22 849 6000 Fax: +41 22 849 6001 Web: https://ecma-international.org/ Copyright Notice Â© 2022 Ecma International This draft document may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published, and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this section are included on all such copies and derivative works. However, this document itself may not be modified in any way, including by removing the copyright notice or references to Ecma International, except as needed for the purpose of developing any document or deliverable produced by Ecma International. This disclaimer is valid only prior to final version of this document. After approval all rights on the standard are reserved by Ecma International. The limited permissions are granted through the standardization phase and will not be revoked by Ecma International or its successors or assigns during this time. This document and the information contained herein is provided on an "AS IS" basis and ECMA INTERNATIONAL DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY OWNERSHIP RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Software License All Software contained in this document ("Software") is protected by copyright and is being made available under the "BSD License", included below. This Software may be subject to third party rights (rights from parties other than Ecma International), including patent rights, and no licenses under such third party rights are granted under this license even if the third party concerned is a member of Ecma International. SEE THE ECMA CODE OF CONDUCT IN PATENT MATTERS AVAILABLE AT https://ecma-international.org/memento/codeofconduct.htm FOR INFORMATION REGARDING THE LICENSING OF PATENT CLAIMS THAT ARE REQUIRED TO IMPLEMENT ECMA INTERNATIONAL STANDARDS. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of the authors nor Ecma International may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE ECMA INTERNATIONAL "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL ECMA INTERNATIONAL BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
